%!TEX encoding = UTF-8 Unicode 
\documentclass[11pt]{article} %try amsproc, amsart
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper, margin=2.5cm}                   % ... or a4paper or a5paper or ... 
% \geometry{landscape}                % Activate for for rotated page geometry
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{setspace}
\setstretch{1.1}

\usepackage{hyperref}
\hyperbaseurl{}
\urlstyle{same}
\usepackage[ruled,linesnumbered]{algorithm2e}
\newcommand{\lIfElse}[3]{\lIf{#1}{#2 \textbf{else}~#3}}

%\usepackage{times}
\usepackage{letltxmacro}
\usepackage[shortlabels]{enumitem}
\usepackage{kotex}
\usepackage{fancyhdr}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}


% Language selector
\newif\ifen
\entrue % Change to false to export Korean


\ifen
{
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{proposition}{Proposition}
\theoremstyle{definition}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}
\newtheorem{problem}{Problem}
\newtheorem{assumption}{Assumption}
\newtheorem{conjecture}{Conjecture}
}
\else {
\newtheorem{theorem}{정리}
\newtheorem{lemma}{기본정리}
\newtheorem{corollary}{따름정리}
\newtheorem{proposition}{제의}
\theoremstyle{definition}
\newtheorem{example}{예}
\newtheorem{definition}{정의}
\newtheorem{problem}{문제}
\newtheorem{assumption}{가정}
\newtheorem{conjecture}{추측}
}
\fi

\ifen {} \else
\renewcommand*{\proofname}{증명\@} 
\renewcommand{\figurename}{그림}
\renewcommand{\tablename}{표}
\fi


%\numberwithin{equation}{section}
%\numberwithin{theorem}{section}
%\numberwithin{lemma}{section}
%\numberwithin{corollary}{section}
%\numberwithin{proposition}{section}
%\numberwithin{example}{section}
%\numberwithin{definition}{section}
%\numberwithin{problem}{section}
%\numberwithin{assumption}{section}
%\numberwithin{conjecture}{section}



\ifen
\newcommand{\thetitle}{How to apply to college}
\newcommand{\therunningtitle}{\thetitle}
\newcommand{\thedate}{\today}
\newcommand{\theauthor}{Max Kapur}
\else
\newcommand{\thetitle}{대학 지원 최적화 문제}
\newcommand{\therunningtitle}{\thetitle}
\newcommand{\thedate}{\today}
\newcommand{\theauthor}{Max Kapur}
\fi



\title{\thetitle}
\author{\theauthor}
\date{\thedate}



\pagestyle{fancy}
\renewcommand{\headrulewidth}{0pt}
\fancyhf{}
\lhead{\theauthor}
\chead{\thedate}
\rhead{\thetitle}
\cfoot{\thepage}


\begin{document}

\maketitle


\begin{abstract}
This paper considers the maximization of the expected maximum value of a portfolio of random variables subject to a budget constraint. We refer to this as the optimal college application problem. When each variable's cost, or each college's application fee, is identical, we show that the optimal portfolios are nested in the budget constraint, yielding an exact polynomial-time algorithm. When colleges differ in their application fees, we show that the problem is NP-complete. We provide three algorithms for this more general setup. The first is a branch-and-bound routine. The second is an dynamic program that produces an exact solution in pseudopolynomial time. The third is a fully polynomial-time approximation scheme.

\ifen
\else The full text of this paper is available in English at \url{https://github.com/maxkapur/OptimalApplication}.\fi
\end{abstract}


\renewcommand{\abstractname}{요약}
\begin{abstract}
본 논문은 다수의 확률 변수로 구성된 포트폴리오의 기대 최대값을 예산 조건 하에서 최대화하는 문제를 고려한다. 이를 대학 지원 최적화 문제라고 부른다. 각 확률 변수의 비용, 즉 각 대학의 지원 비용이 동일한 경우, 최적 포트폴리오는 예산 제약식으로 결정된 포함 사슬 관계 성질을 가짐을 보이고 이를 바탕으로 다항 시간 해법을 제시한다. 대학의 지원 비용이 서로 다른 경우, 문제가 NP-complete함을 증명한다. 세 가지 일반적인 해법을 도출한다. 첫째는 분지한계 기반 해법이다. 둘째는 의사 다항 시간 안에 정확한 해를 출력하는 동적 계획 해법이다. 마지막으로 다른 동적 계획 기반으로 완전 다항 시간 근사 해법(fully polynomial-time approximation scheme)이 존재함을 보인다.

\ifen 본 논문은 \url{https://github.com/maxkapur/OptimalApplication}에서 전문을 한글로 공유한다. \fi
\end{abstract}
\pagebreak

\tableofcontents



\pagebreak
\ifen \section{Introduction}  \else \section{서론} \fi
\ifen This paper considers the following optimization problem:
\else 본 논문은 다음과 같은 최적화 문제를 고려한다.\fi
%\begin{definition}[Optimal college application portfolio] \label{generalproblemstatement}
\begin{align} \label{headlineproblem}
\begin{split}
\text{maximize}\quad & v(\mathcal{X}) =  \operatorname{E}\Bigl[\max\bigr\{t_0,
\max\{t_j Z_j : j \in \mathcal{X}\}\bigr\}\Bigr] \\
\text{subject to}\quad & \mathcal{X} \subseteq \mathcal{C}, ~~\sum_{j\in \mathcal{X}} g_j \leq H
\end{split}
\end{align}
%\end{definition}
\ifen Here $\mathcal{C} = \{ 1 \dots m\}$ is an index set; $H > 0$ is a budget parameter; for $j = 1 \dots m$, $g_j > 0$ is a cost parameter and $Z_j$ is a random, independent Bernoulli variable with probability $f_j$; and for $j = 0\dots m$, $t_j\geq 0$ is a utility parameter. 
\else 단,  $\mathcal{C} = \{ 1 \dots m\}$은 지표 집합이며 $H$는 예산을 나타내는 모수이다. 각 $j = 1 \dots m$에 대해 $g_j > 0$는 비용 모수이며 $Z_j$는 확률 $f_j$를 가지는 서로 독립적인 Bernoulli 변수이다. 각 $j = 0 \dots m$에 대해 $t_j\geq 0$는 효용 모수이다. \fi

\ifen
We refer to this problem as the \emph{optimal college application} problem, as follows. Consider an admissions market with $m$ colleges. The $j$th college is named $c_j$. Consider a single prospective student in this market, and let each $t_j$-value indicate the utility she associates with attending $c_j$, where her utility is $t_0$ if she does not attend college. Let $g_j$ denote the application fee for $c_j$ and $H$ the student's total budget to spend on application fees. (Alternatively, the budget constraint may represent the time needed to complete each application, or a legal limit on the number of applications permitted.) Lastly, let $f_j$ denote the student's probability of being admitted to $c_j$ if she applies, so that $Z_j$ equals one if she is admitted and zero if not. It is appropriate to assume that the $Z_j$ are statistically independent as long as $f_j$ are probabilities estimated specifically for this student (as opposed to generic acceptance rates). Then the student's objective is to maximize the expected utility associated with the best school she gets into within this budget. Therefore, her optimal college application strategy is given by the solution $\mathcal{X}$ to the problem above, where $\mathcal{X}$ represents the set of schools to which she applies. (The problem is also conformable to other competitive matching games such as job application.)
\else
다음 해석에 따라 이를 `대학 지원 최적화 문제'라고 부른다. $m$개의 대학교를 가지는 입학 시장을 고려하자. $j$번째 학교의 이름은 $c_j$이다. 어떤 학생이 $c_j$에 입학하게 되면 효용 $t_j$를 얻게 된다고 하자. 단, 어떤 대학에도 진학하지 않는 경우 그 학생의 효용은 $t_0$이다. $c_j$의 지원 비용이 $g_j$이며 학생이 지원에 쓸 수 있는 예산이 $H$라고 하자. (예산 제약 조건은 또한 원서를 작성하는 시간이나 지원 개수에 대한 법적인 제한을 나타낼 수도 있다.) 마지막으로, $c_j$에 지원하면 학생이 합격할 확률이 $f_j$이라고 하자. 따라서 합격하면 $Z_j = 1$, 합격 안 하면 $Z_j = 0$이 된다. $f_j$가 (학교의 전체적인 합격률이 아니라) 바로 이 학생의 합격 확률일 때 $Z_j$의 확률적 독립성은 적절한 가정이다. 그러면 학생의 목표는 주어진 예산 안에서 학생이 합격하는 학교들에서 얻는 효용 중 기대 최대값을 최대화하는 것이다. 위 문제의 최적해가 $\mathcal{X}$일 때, 학생의 최적 대학 지원 전략은 $\mathcal{X}$에  속한 학교로 지원하는 것이다. (취직 전략과 같은 유사한 경쟁적 매칭 게임에도 위에 문제를 적용할 수 있다.)
\fi

\ifen
The college application problem is not solely of theoretical interest. In the American college consulting industry, students pay private consultants an average of \$200 per hour for assistance in preparing application materials, estimating their admissions odds, and identifying target schools (Sklarow 2018). In Korea, an important revenue stream for admissions consulting firms such as Megastudy (\url{megastudy.net}) and Jinhak (\url{jinhak.com}) is ``mock application'' software that claims to use artificial intelligence to optimize the client's application strategy.  Due to the widespread perception that career earnings depend on college admissions outcomes, the solution of \eqref{headlineproblem} holds monetary value. However, although predicting admissions outcomes on a school-by-school basis is a standard benchmark for regression models (Acharya et al. 2019), we believe our study is the first to formulate the overall application strategy as an optimization problem. 
\else
대학 지원 최적화 문제는 이론적인 화제일 뿐만이 아니다. 미국 입학 컨설팅 산업에서 대학 지원 서류 작성, 합격 확률 추정, 그리고 지원 학교를 선택하는 데에 자문하는 개인 상담가의 시간당 급료는 평균 200달러이다 (Sklarow 2018). 한국에서, 메가스터디(\url{megastudy.net})와 진학(\url{jinhak.com})과 같은 입학 컨설팅 기업의 주된 수입원 중 인공지능을 활용해서 학생의 지원 전략을 최대화한다고 홍보하는 ``모의 지원'' 소프트웨어가 있다. 미래의 소득이 대학 입학 결과로 결정된다는 넓은 인식에 따라, \eqref{headlineproblem}의 최적해는 금전적인 가치를 가지고 있다. 그러나, 학교 개별 합격 확률을 추정하는 것은 회귀 분석 모형의 익숙한 응용 사례(Acharya et al. 2019)이지만, 전체적인 지원 전략을 최적화 문제로 모형화한 것은 본 연구의 새로운 기여로 보인다.
\fi

\ifen
From a methodological standpoint, as Chao (2014) remarked, college application represents a somewhat subtle asset allocation problem. In computational finance, traditional portfolio optimization models weigh the sum of expected profit across all assets against a risk term, yielding a concave maximization problem with linear constraints (Markowitz 1952; Meucci 2005). But college applicants maximize the expected value of their \emph{best} asset: If a student is admitted to her $j$th choice, then she is indifferent as to whether she gets into her $(j+1)$th choice. As a result, the valuation function that students maximize is \emph{convex} in the expected utility associated with individual applications. Risk management is implicit in the college application problem because, in a typical admissions market, college preferability is negatively correlated with competitiveness. That is, students negotiate a tradeoff between attractive, selective “reach schools” and less preferable “safety schools” where admission is a safer bet (Kim 2015). Finally, the combinatorial nature of the college application problem makes it difficult to solve using the gradient-based techniques used in continuous portfolio optimization. Chao estimated her equilibrium model (which considers application as a \emph{cost} rather than a constraint) by clustering the schools so that $m=8$, a scale at which enumeration is tractable. We pursue a more general solution.
\else
방법론적인 관점에서 보면, Chao (2014)가 주장한 바처럼 대학 지원 전략은 약간 미묘한 자산 배분 문제이다. 재정학 분야에서 고전적 포트폴리오 최적화 모형은 전체 자산에 대한 기대 총이익에서 위험회피 항을 뺌으로 선형식으로 제약된 오목 최대화 문제를 이룬다 (Markowitz 1952; Meucci 2005). 그러나 대학 지원자는 가치가 제일 높은 단일 자산의 기대 가치를 최대화하고자 한다. 어떤 학생이 자신이 $j$번째로 선호하는 학교에 합격하면 $(j+1)$번째 학교의 합격 여부는 무관한 상황이 된다. 이는 학생이 최대화하려는 함수를 각 지원 발송의 기대 효용에 대해 오목이 아닌 볼록 함수로 만든다. 또한 입학 시장에서는 전형적으로 대학의 효용과 합격 확률이 서로 반비례하므로 대학 지원 문제는 위험 관리를 포함하게 된다. 특히 선호도가 높으며 붙기 어려운 “상향” 지원 학교(reach school)와 선호도가 낮으며 붙기 쉬운 “안정” 지원 학교(safety school) 사이의 균형을 고려해야 한다 (김민희 2015). 마지막, 대학 지원의 조합적인 본성으로 인해 연속적인 포트폴리오 최적화 문제에서 흔히 사용하는 기울기 해법으로는 풀기가 어렵다. Chao는 지원 비용을 제약 조건 대신 목적함수의 한 항으로 모형화했으며, 균형 모형의 모수를 추정하기 위해 $m=8$이 되도록 학교들의 클러스터를 먼저 구성했다. 이는 열거법을 통해 문 쉽게 풀 수 있는 규모이지만 본 연구는 더 일반적인 $m$에 대한 해법을 추구한다.
\fi

\ifen
The integer formulation of the college application problem can also be viewed as a kind of binary knapsack problem with a polynomial objective function of degree $m$. Our branch-and-bound and dynamic programming algorithms closely resemble existing algorithms for knapsack problems (Martello and Toth 1990, \S\,2.5--6). In fact, by manipulating the admissions probabilities, the objective function can be made to approximate a linear function of the characteristic vector to an arbitrary degree of accuracy, a fact that we exploit in our NP-completeness proof. Previous research has introduced various forms of stochasticity to the knapsack problem, including variants in which each item's utility takes a known probability distribution (Steinberg and Parks 1979; Carraway et al. 1993) and an online context in which the weight of each item is observed after insertion into the knapsack (Dean et al. 2008). Our problem superficially resembles the preference-order knapsack problem considered by Steinberg and Parks and Carraway et al., but these models lack the college application problem's singular ``maximax'' form. Additionally, unlike those models, we do not attempt to replace the real-valued objective function with a preference order over \emph{outcome distributions,} which introduces technical issues concerning competing notions of stochastic dominance (Sniedovich 1980). We take for granted the student's preferences over \emph{outcomes} (as encoded in the $t_j$-values), and focus instead on an efficient computational approach to the well-defined problem above.
\else
대학 지원 문제의 정수 모형은 $m$차 다항식을 목적함수로 갖춘 일종의 이진 배낭 문제로 볼 수도 있다. 본 논문에서 제시하는 분지한계법과 동적 계획 해법은 배낭 문제를 위한 기존 알고리즘과 매우 비슷하다 (Martello와 Toth 1990, \S\,2.5--6). 입학 확률을 적당히 조정하면 특성벡터의 선형 함수를 원래 목적함수로 원하는 만큼의 정확성을 가지고 근사할 수 있으며 NP-completeness 증명에서 이 성질을 활용한다. 배낭 문제에 확률성을 도입한 선행 연구 중, 각 상품의 효용이 정해진 확률 분포로 결정되는 모형(Steinberg와 Parks 1979; Carraway 외 1993), 그리고 배낭에 삽입한 다음에 상품의 무게를 관측할 수 있는 온라인 모형 (Dean 외 2008) 등이 있다. 본 연구가 고려하는 문제는 Steinberg와 Parks 그리고 Carraway 외가 고려한 ``우선순위 배낭 문제''와는 유사성을 가지지만, 우선순위 배낭 문제는 대학 지원 문제의 특색인 `maximax' 형태를 가지지는 않는다. 또한 우선순위 모형과 달리, 본 연구에서 실수값 목적함수를 선호 순위를 정의해야 하는 `결과 분포'로 대체할 필요가 없다. 확률적 우위에 대한 상반된 개념들의 문제를 야기시키기 때문이다 (Sniedovich 1980). 대신 $t_j$-값으로 유도된 학생의 `결과'에 대한 선호 순위를 받아들여 위에서 정의한 것처럼 명확히 정의된 문제를 위한 효율적인 계산법을 지향한다.
\fi

\ifen
We take special interest in the validity of greedy optimization algorithms for the set function $v(\mathcal{X})$, such as the algorithm that iteratively adds the school that elicits the greatest increase in the objective function until the budget is exhausted. Greedy algorithms produce a \emph{nested} family of solutions parameterized by the budget $H$: If $H \leq H'$, then the greedy solution for budget $H$ is a subset of the greedy solution for budget $H'$. As Rozanov and Tamir (2020) remark, the knowledge that the optima are nested aids not only in computing the optimal solution, but in the implementation thereof under uncertain information. For example, in the United States, many college applications are due at the beginning of November, and it is typical for students to begin working on their applications during the prior summer because colleges reward students who tailor their essays to the target school. However, students may not know how many schools they can afford to apply to until late October. The nestedness property---or equivalently, the validity of a greedy algorithm---implies that even in the absence of complete budget information, students can begin to carry out the optimal application strategy by writing essays for schools in the order that they enter the optimal portfolio.
\else
본 연구에서 특히 탐욕 해법의 가능성에 관심을 기울인다. 예를 들어 예산이 다 소비될 때까지 목적함수를 가장 많이 증가시키는 학교를 차례대로 추가하는 알고리즘은 일종의 탐욕 해법이다. 탐욕 해법은 예산 $H$로 모수화된 해의 순서를 유도하며 그의 원소들은 `포함 사슬 관계'(nestedness)로 연결된다. 즉 $H \leq H'$일 때, 예산 $H$에 해당하는 탐욕 해는 예산 $H'$에 해당하는 탐욕 해의 부분집합이 된다. Rozanov와 Tamir (2020)가 주장하듯, 최적해가 포함 사슬 관계를 가지면 최적해를 구하는 것뿐 아니라 정보가 불확실한 상황에서 최적해를 구현하는 데에도 유용하다. 가령, 많은 미국 대학의 지원 기한은 11월 초인데 학업 계획서를 학교의 취향에 맞춰서 작성해야 하므로 여름부터 원서를 작성하는 학생이 많다. 그러나 지원 예산은 10월 말까지 모를 수도 있다. 포함 사슬 관계, 또는 탐욕 해법의 타당성은 완전한 예산 정보가 없어도 학교가 최적 포트폴리오에 진입하는 순서대로 원서를 작성하면 최적 전략을 구현해 낼 수 있음을 의미한다.
\fi

\ifen
For certain classes of optimization problems, such as maximizing a submodular set function over a cardinality constraint, a greedy algorithm is known to be a good approximate solution and exact under certain additional assumptions (Fisher et al. 1978). For other problems, notably the binary knapsack problem, the most intuitive greedy algorithm can be made to perform arbitrarily poorly (Vazirani 2001). We show results for the college application problem that mirror those for knapsack: In the special case where each $g_j = 1$, the optimal portfolio satisfy a nestedness property that is equivalent to the validity of the greedy algorithm. This case mirrors the centralized college application process in Korea, where there is no application fee, but students are allowed to apply to only three schools during the main admissions cycle. Unfortunately, the nestedness property does not hold in the general case, nor does the greedy algorithm offer any performance guarantee. Instead, we offer a branch-and-bound routine, a pseudopolynomial-time algorithm that is tractable for typical college market instances, and an approximation scheme that produces a $(1 - \varepsilon)$-optimal solution in fully polynomial time.
\else
탐욕 알고리즘이 좋은 근사해거나 정확한 알고리즘이 되는 최적화 모형들이 알려져 있다. 집합 크기 제약 하에서 하위 모듈 집합 함수(submodular set function)를 최대화하는 문제가 대표적인 예다 (Fisher 외 1978). 반면에 이진 배낭 문제 같은 경우에서는 가장 직관적인 탐욕 알고리즘이 최적과 거리가 먼 해를 출력하는 예를 만들 수 있다 (Vazirani 2001). 대학 지원 문제와 배낭 문제가 서로 매우 유사함을 보인다. 모든 $g_j=1$인 특수한 경우에서, 최적 포트폴리오가 탐욕 알고리즘의 타당성과 동등한 포함 사슬 관계를 만족하는 것을 증명한다. 이 경우는 지원 비용이 없으며 정시 모집 기간에 학교 3개에만 지원할 수 있는 한국 입학 과정과 같다. 그러나 일반적인 경우에서 포함 사슬 관계가 성립하지 않을뿐더러 탐욕 알고리즘이 어떤 근사 계수를 보장할 수 없을 보일 수 있다. 대신 분지한계법, 전형적인 입학 시장 인스턴스에 대해 효율적인 의사 다항 시간 동적 계획, 그리고 완전 다항 시간 안에 $(1 - \varepsilon)$-근사해를 출력하는 알고리즘 등 3가지 해법을 제안한다. 
\fi


\ifen \subsection{Structure of this paper} \else \subsection{본 논문의 구성}\fi
\ifen Section \ref{preliminaries} introduces some additional notation and assumptions that can be imposed without loss of generality. 
\else \ref{preliminaries}절은 표기법과 일반성을 제한하지 않는 편의적 가정을 제시한다.\fi

\ifen
In Section \ref{homogappcosts}, we consider the special case where each $g_j = 1$ and $H$ is an integer $h \leq m$.  We show that an intuitive heuristic is in fact a $1/h$-approximation algorithm. Then, we show that the optimal portfolios are nested in the budget constraint, which yields an exact algorithm that runs in $O(hm)$-time.
\else
\ref{homogappcosts}절에서 각 $g_j = 1$이고 $H$가 $h \leq m$이고 자연수인 특수한 경우를 고려한다. 직관적인 휴리스틱 해법이 실제로 $1/h$-근사 해법임을 증명한다. 그다음에 최적 포트폴리오의 예산 제약에 대한 포함 사슬 관계를 보이고 이를 이용해서 $O(hm)$-시간 정확한 해법을 도출한다.
\fi

\ifen
In Section \ref{hetappcosts}, we turn to the scenario in which colleges differ in their application fees. We show that the decision form of the portfolio optimization problem is NP-complete through a polynomial reduction from the binary knapsack problem. We provide three algorithms for this more general setup. The first is a branch-and-bound routine. The second is a dynamic program that iterates on total expenditures and produces an exact solution in pseudopolynomial time, namely $O(Hm + m \log m)$. The third is a different dynamic program that iterates on truncated portfolio valuations. It yields a fully polynomial-time approximation scheme that produces a $(1 - \varepsilon)$-optimal solution in $O(m^3 / \varepsilon)$ time.  
\else
\ref{hetappcosts}절에서 각 학교의 지원 비용이 동일하지 않은 일반적인 상황을 다룬다. 이진 배낭 문제에서의 다항 변환을 통해서 포트폴리오 최적화 문제가 NP-complete임을 증명한다. 또한 3개의 일반적인 해법을 제안한다. 첫째는 분지한계법이다. 둘째는 총 지출액으로 탐색하는 $O(Hm + m \log m)$과 같은 의사 다항 시간 동적 계획 해법이다. 셋째는 실수값을 분수값으로 내림한 포트폴리오 가치를 탐색하는 또다른 동적 계획 해법이다. 이를 통해서 $O(m^3 / \varepsilon)$-시간 안에 $(1 - \varepsilon)$-근사해를 출력하는 완전 다항 시간 근사 해법(fully polynomial-time approximation scheme)을 얻는다.
\fi

\ifen
In Section \ref{numericalexperiments}, we present the results of computational experiments that confirm the validity and time complexity results established in the previous two sections.

A brief conclusion follows.
\else
\ref{numericalexperiments}절에서 위에서 도출한 타당성과 계산 복잡성을 확인하는 계산 실험 결과를 정리한다. 

그리고 간단한 결론을 제시한다.
\fi



%\pagebreak
\ifen \section{Notation and preliminary results} \else \section{표기법과 예비 결과}\fi\label{preliminaries}
\ifen Before discussing the solution algorithms, we will introduce some additional notation and a few preliminary results that will come in handy.

For the remainder of the paper, unless otherwise noted, we assume with trivial loss of generality that each $g_j \leq H$, each $f_j \in (0, 1]$, and $t_0 < t_1 \leq \cdots \leq t_m$. Below, we will show how to transform an arbitrary instance so that $t_0 = 0$, in which case each $t_j > 0$. 
\else
해법은 의논하기 전, 본 절에서 추가적인 표기법은 명시하고 몇 가지 유용한 예비 결과를 정리하고자 한다.

남은 논문에서 다른 언급이 없으면, 일반성을 잃지 않고 각 $g_j \leq H$, 각 $f_j \in (0, 1]$, 그리고 $t_0 < t_1 \leq \cdots \leq t_m$이라고 가정한다. 뒤에서 임의의 인스턴스를 $t_0 = 0$이 되도록 변환하는 방법을 제시하는데 이를 적용하면 $t_j > 0$인 가정을 세울 수 있다. 
\fi

\ifen
We refer to the set $\mathcal{X} \subseteq \mathcal{C}$ of schools to which a student applies as her \emph{application portfolio.} The expected utility the student receives from $\mathcal{X}$ is called its \emph{valuation}. %Let $x$ denote the same encoded as a binary vector, where $x_j=1 \iff j\in \mathcal{X}$ for $j=1\dots m$.
\else
학생이 지원하는 학교 집합 $\mathcal{X} \subseteq \mathcal{C}$를 `지원 포트폴리오'라고 부르자. $\mathcal{X}$에서 학생이 받는 기대 효용을 포트폴리오의 `가치'라고 한다.
\fi 
\begin{definition}[\ifen Portfolio valuation function\else 포트폴리오 가치 함수\fi]
$v(\mathcal{X}) =  \operatorname{E}\left[\max\bigr\{t_0,
\max\{t_j Z_j : j \in \mathcal{X}\}\bigr\}\right]$.
\end{definition}
\ifen
It is helpful to define the random variable $X  = \max\{ t_j Z_j : j \in \mathcal{X}\}$ as the utility achieved by the schools in the portfolio, so that when $t_0 = 0$, $v(\mathcal{X}) = \operatorname{E}[X]$. Similar pairs of variables with script and italic names such as $\mathcal{Y}_h$ and $Y_h$ carry an analogous meaning.
\else
편의상 포트폴리오에 속한 학교가 실제로 이루는 효용을 확률 변수 $X  = \max\{ t_j Z_j : j \in \mathcal{X}\}$로 정의한다. 그러면 $t_0 = 0$이면 $v(\mathcal{X}) = \operatorname{E}[X]$임을 알 수 있다. 비슷한 식으로 $\mathcal{Y}_h$와 $Y_h$ 같은 스크립트체와 이탈릭체로 표기한 변수 쌍은 유사한 의미를 가진다.
\fi

\ifen
Given an application portfolio, let $p_j(\mathcal{X})$ denote the probability that the student attends $c_j$. This occurs if and only if she \emph{applies} to $c_j$, is \emph{admitted} to $c_j$, and is \emph{rejected} from any school she prefers to $c_j$; that is, any school with higher index. Hence, for $j= 0\dots m$,
\else
주어진 지원 포트폴리오에 대해 학생이 $c_j$로 진학할 확률을 $p_j(\mathcal{X})$라고 하자. 이 사건이 발생하는 필수충분 조건은 $c_j$에 지원하고, $c_j$에서 합격받고, $c_j$보다 선호하는 (즉, 지표가 더 높은) 학교에서 불합격받는 것이다. 따라서  $j= 0\dots m$에 대해
\fi
\begin{align}
p_j(\mathcal{X}) &= 
\begin{cases}
\displaystyle f_j  \prod_{\substack{i \in \mathcal{X}: \\ i > j}} (1 - f_{i}), \quad & j \in \{0\}\cup\mathcal{X}\\
0, \quad & \text{\ifen otherwise\else otherwise.\fi}
\end{cases} 
\end{align}
\ifen
where the empty product equals one. The following proposition follows immediately.
\else
단, 공집합의 곱은 1이다. 다음 제의는 직설적인 결과다.
\fi

\begin{proposition}[\ifen Closed form of portfolio valuation function\else 포트폴리오 가치 함수의 다른 식\fi]
\begin{align}
v(\mathcal{X}) &= \sum_{j=0}^m t_j p_j(\mathcal{X}) = \sum_{j\in\{0\}\cup\mathcal{X}} \Bigl( f_j t_j \prod_{\substack{i \in \mathcal{X}: \\ i > j}} (1 - f_{i}) \Bigr)  \label{closedformportfoliovaluationX}%, \quad \text{or equivalently,}\\
%\qquad v(x) &= t_0 \prod_{j=1}^m (1 - f_{j} x_j) + \sum_{j=1}^m \Bigl( x_j t_j f_j \prod_{j’ = j+1}^m (1 - f_{j’} x_{j’}) \Bigr) \label{closedformportfoliovaluationx}
\end{align}
\end{proposition}
%\begin{proof}Computing $v(\mathcal{X}) = \sum_{j=0}^m  t_j p_j(\mathcal{X})$ yields \eqref{closedformportfoliovaluationX}. Next, because $1 - f_j x_j = 1$ if $x_j = 0$, we may define $p_j$ equivalently as $p_j(x) = x_j  f_j \prod_{j’ = j+1}^m (1 - f_{j’} x_{j’})$ to obtain \eqref{closedformportfoliovaluationx}. 
%\end{proof}

\ifen
Next, we show that without loss of generality, we may assume that $t_0 = 0$ (or any constant less than $t_1$).
\else
그다음에, 일반성을 제한하지 않고 $t_0 = 0$(또는 $t_1$보다 작은 임의의 상수)이라고 가정할 수 있음을 보이자.
\fi
\begin{theorem} \label{assumetzerozero}
Let $\bar t_j = t_j - \gamma$ for $j = 0 \dots m$. Then $v(\mathcal{X}; \bar t_j) = v(\mathcal{X};  t_j) -  \gamma$ regardless of $\mathcal{X}$. 
\end{theorem}
\begin{proof}
\ifen
By definition, $\sum_{j=0}^m p_j(\mathcal{X}) = \sum_{j \in \{0\}\cup\mathcal{X}} p_j(\mathcal{X}) = 1$. Therefore
\else
정의에 따라 $\sum_{j=0}^m p_j(\mathcal{X}) = \sum_{j \in \{0\}\cup\mathcal{X}} p_j(\mathcal{X}) = 1$이다. 그러면 다음 수식으로 증명을 완성할 수 있다.
\fi
\begin{align}
\begin{split}
v(\mathcal{X}; \bar t_j) &= \sum_{j\in \{0\}\cup\mathcal{X}}  \bar t_j p_j(\mathcal{X})
=\sum_{j\in \{0\}\cup\mathcal{X}} (t_j - \gamma) p_j(\mathcal{X}) \\
&=\sum_{j\in \{0\}\cup\mathcal{X}} t_j p_j(\mathcal{X})  - \gamma 
= v(\mathcal{X}; t_j) - \gamma
\end{split} \ifen\else\qedhere\fi
\end{align}
\ifen which completes the proof.\fi
\end{proof}




\ifen \section{Homogeneous application costs}  \else \section{동일한 지원 비용} \fi \label{homogappcosts}
\ifen In this section, we focus on the special case in which each $g_j = 1$ and $H$ is a natural number $h \leq m$.   We show that an intuitive heuristic is in fact a $1/h$-approximation algorithm, then derive an exact polynomial-time solution algorithm.
This case is similar to the centralized college admissions process in Korea, where there is no application fee, but by law, students are allowed to apply to no more than $h$ schools. (In the Korean case, $m=202$ and $h=3$.) Applying Theorem \ref{assumetzerozero}, we assume that $t_0 = 0$ unless otherwise noted. Throughout this section, we will call the applicant Alma, and refer to the corresponding optimization problem as Alma's problem. 
\else
본 절에서 모든 $g_j = 1$이며 $H$가 자연수 $h \leq m$인 특수한 경우에 집중한다. 직관적인 휴리스틱 해법이 실제로 $1/h$-근사 해법임을 보인 다음에 정확한 다항 시간 해법을 도출한다. 이 특수한 경우는 지원 비용이 없으며 국가 법에 따라 최대 $h$개의 학교에 지원할 수 있는 한국의 중심화된 대학 지원 과정과 비슷하다. (한국 경우,  $m=202$이고 $h=3$이다.) 정리 \ref{assumetzerozero}을(를) 적용해서 다른 언급이 없으면 $t_0 = 0$임을 가정하자. 본 절 내내 지원자를 `알마'라고 부르고 해당 최적화 문제를 `알마의 문제'라고 부른다.
\fi

\begin{problem}[\ifen Alma’s problem\else 알마의 문제\fi]
\ifen Alma's optimal college application portfolio is given by the solution to the following combinatorial optimization problem:
\else
알마의 최적 대학 지원 포트폴리오는 다음 조합 최적화 문제의 최적해이다.
\fi
\begin{align}
\begin{split}
\text{maximize}\quad &  v(\mathcal{X}) = \sum_{j\in
%\{0\}\cup
\mathcal{X}} \Bigl( f_j t_j \prod_{\substack{i \in \mathcal{X}: \\ i > j}} (1 - f_{i}) \Bigr)\\
\text{subject to}\quad & \mathcal{X}\subseteq\mathcal{C}, \quad|\mathcal{X}| \leq h 
\end{split}
\end{align}
\end{problem}
%This problem can be formulated as an integer nonlinear program in $m$ binary variables .. 

\ifen \subsection{Approximation properties of a na\"ive solution}  \else \subsection{나이브 해법의 근사 성질} \fi
\ifen
The expected utility associated with a single school $c_j$ is simply $\operatorname{E}[t_j Z_j] = f_j t_j$. It is therefore tempting to adopt the following strategy, which turns out to be inoptimal.
\else 
단일 학교 $c_j$에 해당하는 기대 효용이 단순히 $\operatorname{E}[t_j Z_j] = f_j t_j$이므로 다음과 같은 알고리즘이 매력적으로 보일 수 있지만 사실은 최적해가 아니다.
\fi
\begin{definition}[\ifen Na\"ive algorithm for Alma’s problem\else 알마의 문제를 위한 나이브 해법\fi] \label{naivealgorithm}
\ifen 
Apply to the $h$ schools having the highest expected utility $f_j t_j$.
\else
기대 효용 $f_j t_j$가 가장 높은 $h$개의 학교로 지원한다.
\fi
\end{definition}
\ifen 
The basic error of this algorithm is that it maximizes $\operatorname{E}\left[\sum t_j Z_j \right]$ instead of $\operatorname{E}\left[\max \{t_j Z_j\} \right]$. The latter is what Alma is truly concerned with, since in the end she can attend only one school. The following example shows that the na\"ive algorithm can produce a suboptimal solution.
\else
위 알고리즘의 기본 실수는 $\operatorname{E}\left[\max \{t_j Z_j\} \right]$ 대신  $\operatorname{E}\left[\sum t_j Z_j \right]$을 최대화하는 것이다. 결국에는 단 한 학교로만 진학할 수 있으므로 알마의 목적은 후자가 아닌 전자다. %학교 개별 효용의 기대 최대값이다. 
다음 예는 나이브 해법이 최적해가 아닌 해를 출력할 수 있음을 보인다.
\fi
\begin{example}
\ifen 
Suppose $m=3$, $h=2$,  $ t= (70, 80, 90) $, and $f = (0.4, 0.4, 0.3)$. 
%\implies t * f &= (28, 32, 27)
%\begin{align*}
%t &= (70, 80, 90) \\
%f &= (0.4, 0.4, 0.3) \\
%\implies t * f &= (28, 32, 27)
%\end{align*}
Then the na\"ive algorithm picks $\mathcal{T} = \{1, 2\}$ with 
$v(\mathcal{T}) = 70(0.4)(1-0.4) + 80(0.4) = 48.8$.
But $\mathcal{X} = \{2, 3\}$ with
$v(\mathcal{X}) = 80(0.4)(1-0.3) + 90(0.3) = 49.4$
is the optimal solution. 
\else
$m=3$, $h=2$,  $ t= (70, 80, 90) $, 그리고 $f = (0.4, 0.4, 0.3)$이라고 하자. 그러면 나이브 해법은 $\mathcal{T} = \{1, 2\}$를 선택하며 그의 기대 효용은 $v(\mathcal{T}) = 70(0.4)(1-0.4) + 80(0.4) = 48.8$이다. 그러나 $\mathcal{X} = \{2, 3\}$를 선택하면 기대 효용은 $v(\mathcal{X}) = 80(0.4)(1-0.3) + 90(0.3) = 49.4$이고 이는 최적해다.
\fi
\end{example}

\ifen
In fact, the na\"ive algorithm is a $(1/h)$-approximation algorithm for Alma’s problem, as expressed in the following theorem.
\else
다음 정리는 나이브 해법이 알마의 문제를 위한 $(1/h)$-근사 해법임을 의미한다.
\fi

\begin{theorem}[\ifen Accuracy of the na\"ive algorithm\else 나이브 해법의 정확성\fi] \label{oneoverhopt}
\ifen 
When the application limit is $h$, let $\mathcal{X}_h$ denote the optimal portfolio, and $\mathcal{T}_h$ the set of the $h$ schools having the largest values of $f_j t_j$. Then $v(\mathcal{T}_h) / v(\mathcal{X}_h) \geq 1/h$. 
\else
지원 제한이 $h$일 때, 최적 포트폴리오가 $\mathcal{X}_h$이고 기대 효용 $f_j t_j$가 가장 높은 $h$개의 학교의 집합이 $\mathcal{T}_h$라고 하자. 그러면 $v(\mathcal{T}_h) / v(\mathcal{X}_h) \geq 1/h$이다.
\fi
\end{theorem}
\begin{proof}
\ifen
Because $\mathcal{T}_h$ maximizes the quantity $\operatorname{E}\bigl[ \sum_{j \in \mathcal{T}_h}\{ t_j Z_j \}\bigr]$, we have
\else
$\mathcal{T}_h$는 $\operatorname{E}\bigl[ \sum_{j \in \mathcal{T}_h}\{ t_j Z_j \}\bigr]$를 최대화하므로,
\fi
\begin{align} \label{oneoverhopt}
\begin{split}
v(\mathcal{X}_h) &= \operatorname{E}\Bigl[ \max_{j \in \mathcal{X}_h}\{ t_j Z_j \}\Bigr] \leq \operatorname{E}\Bigl[ \sum_{j \in \mathcal{X}_h}\{ t_j Z_j \}\Bigr] \leq \operatorname{E}\Bigl[ \sum_{j \in \mathcal{T}_h}\{ t_j Z_j \}\Bigr] \\
&= h  \operatorname{E}\Bigl[ \tfrac{1}{h} \sum_{j \in \mathcal{T}_h}\{ t_j Z_j \}\Bigr]
\leq h  \operatorname{E}\Bigl[ \max_{j \in \mathcal{T}_h}\{ t_j Z_j \}\Bigr]
= h v(\mathcal{T}_h).
\end{split}
\end{align}
\ifen 
where the final inequality follows from the concavity of the $\max\{\}$ operator.
\else
단, 마지막 부등호는 $\max\{\}$ 연산의 볼록성에 따라 성립한다.
\fi
\end{proof}

\ifen
The following example establishes the tightness of the approximation factor. 
\else
다음 예는 근사 계수가 타이트(tight)함을 보인다.
\fi

\begin{example} \label{tightexampleforoneoverhopt}
\ifen
Pick any $h$ and let $m = 2h$. For a small constant $\varepsilon \in (0, 1)$, define the market as follows.
\else
임의의 $h$를 택하고 $m = 2h$라고 하자. 작은 상수  $\varepsilon \in (0, 1)$에 대해 시장을 다음처럼 구성한다.
\fi
\begin{align*}
t &= \Bigl(\,\underbrace{1,  \dots, 1}_{h},\;
\underbrace{\varepsilon^{-1}, \varepsilon^{-2}, \dots, \varepsilon^{-(h-1)}, \varepsilon^{-h}}_{h}\,\Bigr) \\
\text{and}\quad f &= \Bigl(\,\underbrace{1,  \dots, 1}_{h},\;
\underbrace{\varepsilon^{1}, \varepsilon^{2}, \dots, \varepsilon^{h-1}, \varepsilon^{h}}_{h}\,\Bigr)
\end{align*}
\ifen
Since all $f_j t_j = 1$, the na\"ive algorithm can choose $\mathcal{T}_h = \{1, \dots, h\}$, with $v(\mathcal{T}_h) = 1$. But the optimal solution is $\mathcal{X}_h = \{h+1, \dots, m\}$, with
\else
모든 $f_j t_j = 1$이므로 나이브 해법은 $\mathcal{T}_h = \{1, \dots, h\}$를 출력할 수 있으며 $v(\mathcal{T}_h) = 1$이다. 그러나 최적해는 $\mathcal{X}_h = \{h+1, \dots, m\}$이며 그의 기대 효용은 다음과 같다.
\fi
\begin{equation*}
v(\mathcal{X}_h) = \sum_{j= h +1}^m \Bigl( f_j t_j \prod_{j' = j+1}^m (1 - f_{j'}) \Bigr) =  \sum_{j= 1}^h  (1 - \varepsilon)^{j} \approx h\ifen.\fi
\end{equation*}
\ifen
Thus, as $\varepsilon$ approaches zero, we have $v(\mathcal{T}_h) / v(\mathcal{X}_h) \to 1/h$. (The optimality of $\mathcal{X}_h$ follows from the fact that it achieves the upper bound of Theorem \ref{oneoverhopt}.)
\else
따라서 $\varepsilon$이 0에 가까워지면서 $v(\mathcal{T}_h) / v(\mathcal{X}_h) \to 1/h$이 된다.  ($\mathcal{X}_h$의 최적성은 정리 \ref{oneoverhopt}이(가) 제시하는 상한을 실천하기 때문에 성립한다.)
\fi
\end{example}



%% Wrong: The Fisher theorem would apply to the greedy, i.e. correct algorithm. 
%\begin{corollary}
%\ifen
%The function $v(\mathcal{X})$ is not submodular. 
%\else
%$v(\mathcal{X})$는 하위 모듈 함수가 아니다.
%\fi
%\end{corollary}
%\begin{proof}
%\ifen
%If $v(\mathcal{X})$ is submodular, then theorem 4.2 of Fisher et al. (1978) implies that the na\"ive algorithm achieves an optimality ratio of $v(\mathcal{T}_h) / v(\mathcal{X}_h)  \geq 1 - \left(\frac{h-1}{h}\right)^h$. Example \ref{tightexampleforoneoverhopt} provides a counterexample.
%\else
%$v(\mathcal{X})$가 하위 모듈 함수라면 Fisher 외(1978)의 정리 4.2는 나이브 해법이 $v(\mathcal{T}_h) / v(\mathcal{X}_h)  \geq 1 - \left(\frac{h-1}{h}\right)^h$ 같은 근사 비율을 이룬다고 의미한다. 예 \ref{tightexampleforoneoverhopt}는 반례다.
%\fi
%\end{proof}

\ifen
Although the na\"ive algorithm is inoptimal, we can still find the optimal solution in $O(hm)$-time, as we will now show.
\else
나이브 해법은 최적해가 아니지만 $O(hm)$-시간 안에 최적해를 구할 수 있다.
\fi

\ifen \subsection{The nestedness property}  \else \subsection{포함 사슬 관계} \fi
\ifen It turns out that the solution to Alma's problem possesses a special structure: An optimal portfolio of size $h+1$ includes an optimal portfolio of size $h$ as a subset.
\else 알마의 문제의 최적해에는 특별한 구조가 있다. 크기 $h+1$에 대한 최적 포트폴리오는 항상 크기 $h$에 대한 최적 포트폴리오를 부분집합으로 포함한다.\fi
% Incl above
%To show this result, we need to introduce some new notation. For an application portfolio $\mathcal{X}$, the random variable $X  = \max\{ t_j Z_j : j \in \mathcal{X}\}$ represents the utility achieved by the portfolio, so that $v(\mathcal{X}) = \operatorname{E}[X]$.

% Unused
%It is also helpful to define $\Delta v(\mathcal{X}, j)$ as the utility gained by adding $c_j$ to the portfolio $\mathcal{X}$. That is, 
%\begin{align} \Delta v(\mathcal{X}, j) &= v(\mathcal{X} \cup \{j\})  - v(\mathcal{X}) \\
%&= (1 - f_j) v(\mathcal{X}) + f_j \operatorname{E}[\max\{X, t_j\}] - v(\mathcal{X}) \\
%&= f_j \operatorname{E}[\max\{0, t_j - X\}]  \label{emaxtjminusX}
%\end{align}
%
%\begin{lemma}
%For all $\mathcal{X}\subseteq \mathcal{C}$ and $i, j \in \mathcal{C}$, $\Delta v(\mathcal{X}, j) \geq \Delta v(\mathcal{X} \cup \{i\}, j)$. 
%\end{lemma}
%\begin{proof}
%If a new school $i$ is added to $\mathcal{X}$, then the expected value of $X$ can only increase. Likewise, the probability that Alma is admitted to at least one school in $\mathcal{X}\cup\{i\}$ that she prefers to $j$ must be higher than in $\mathcal{X}$. Therefore, the maximum in \eqref{emaxtjminusX} is more likely to occur in the second entry, and achieves a lower value. 
%\end{proof}
%Now we may present the main result.

\begin{theorem}[\ifen Nestedness of optimal application portfolios\else 최적 포트폴리오의 포함 사슬 관계\fi] \label{nestedapplication}
\ifen There exists a sequence of portfolios $\{\mathcal{X}_h\}_{h=1}^m$ satisfying the nestedness relation \fi
\begin{equation}
\mathcal{X}_1 \subset \mathcal{X}_2\subset \dots \subset \mathcal{X}_m.
\end{equation}
\ifen such that each $\mathcal{X}_h$ is an optimal application portfolio when the application limit is $h$.
\else  각 $\mathcal{X}_h$가 지원 제한 $h$에 대한 최적 포트폴리오며 위의 포함 사슬 관계를 만족하는 포트톨리오 수열  $\{\mathcal{X}_h\}_{h=1}^m$가 존재한다.\fi
\end{theorem}

\begin{proof}\ifen
By induction on $h$. Applying Theorem \ref{assumetzerozero}, we assume that $t_0 = 0$. We also assume that each $f_j < 1$, which is without loss of generality because any school having $f_j = 1$ can be eliminated by setting $t_0 = t_j$ and reapplying the transformation from Theorem \ref{assumetzerozero}.

(Base case.) First, we will show that $\mathcal{X}_1 \subset \mathcal{X}_2$. To get a contradiction, suppose that the optima are $\mathcal{X}_1 = \{j\}$ and $\mathcal{X}_2 = \{k, l\}$, where we may assume that $t_k \leq t_l$. Optimality requires that
\else$h$에 대해 귀납법을 적용한다. 정리 \ref{assumetzerozero}에 따라 $t_0 = 0$이라고 가정한다. 또한 모든 $f_j < 1$임을 가정한다. $f_j = 1$인 학교가 있으면 $t_0 = t_j$로 수정하고  정리 \ref{assumetzerozero}의 변환을 다시 적용해서 소거할 수 있으므로 일반성을 제한하지 않는다.

(기본 경우.) 우선 $\mathcal{X}_1 \subset \mathcal{X}_2$임을 증명하자. 모순을 보이기 위해 최적해가 $\mathcal{X}_1 = \{j\}$와 $\mathcal{X}_2 = \{k, l\}$이라고 하자. 여기서 $t_k \leq t_l$이라고 가정할 수 있다. 최적성에 따라 다음이 성립한다:
\fi
\begin{equation}v(\mathcal{X}_1 )  = f_j t_j > v(\{k\}) = f_k t_k\end{equation}
\ifen and \else 그리고\fi
\begin{align}
\begin{split}
v(\mathcal{X}_2) =  f_k (1- f_l) t_k + f_l t_l &> v(\{j, l\}) \\
& = f_j (1- f_l) t_j + (1- f_j) f_l t_l + f_j f_l \max\{t_j, t_l\} \\
&\geq  f_j (1- f_l) t_j + (1- f_j) f_l t_l + f_j f_l  t_l \\
&= f_j (1- f_l) t_j + f_l t_l  \\
&\geq f_k (1- f_l) t_k + f_l t_l  = v(\mathcal{X}_2)
\end{split}
\end{align}
\ifen which is a contradiction. 
\else 이는 모순이다.\fi

\ifen (Inductive step.) Assume that $\mathcal{X}_1 \subset \cdots \subset \mathcal{X}_h$, and we will show $\mathcal{X}_h \subset \mathcal{X}_{h+1}$. Let $k = \argmax\{ t_k: k \in \mathcal{X}_{h+1}\}$ and write $\mathcal{X}_{h+1} = \mathcal{Y}_{h} \cup \{k\}$.
\else (추론.) $\mathcal{X}_1 \subset \cdots \subset \mathcal{X}_h$라고 가정하고 $\mathcal{X}_h \subset \mathcal{X}_{h+1}$임을 보이자. $k = \argmax\{ t_k: k \in \mathcal{X}_{h+1}\}$으로 정의해서 $\mathcal{X}_{h+1} = \mathcal{Y}_{h} \cup \{k\}$으로 표현하자.\fi

\ifen Suppose $k \notin \mathcal{X}_h$. To get a contradiction, assume that $v(\mathcal{Y}_h) < v(\mathcal{X}_h)$. Then
\else $k \notin \mathcal{X}_h$인 경우를 고려하자. 모순을 보이기 위해 $v(\mathcal{Y}_h) < v(\mathcal{X}_h)$라고 하면 \fi
\begin{align}
\begin{split}
v(\mathcal{X}_{h+1})&= v(\mathcal{Y}_{h} \cup \{k\}) \\
&= (1 - f_k) v(\mathcal{Y}_h) + f_k t_k \\
& < (1 - f_k) v(\mathcal{X}_h) + f_k \operatorname{E}\bigl[ \max\{t_k, X_h\}\bigr]\\
&=  v(\mathcal{X}_h\cup \{k\})
\end{split}
\end{align}
\ifen contradicts the optimality of $\mathcal{X}_{h+1}$.
\else 이는 $\mathcal{X}_{h+1}$의 최적성을 위반한다.\fi

\ifen Now suppose that $k \in \mathcal{X}_h$. We can write $\mathcal{X}_h = \mathcal{Y}_{h-1} \cup \{k\}$, where $ \mathcal{Y}_{h-1}$ is some portfolio of size $h-1$. It suffices to show that $ \mathcal{Y}_{h-1} \subset \mathcal{Y}_h$. By definition, $\mathcal{Y}_{h-1}$ (respectively, $\mathcal{Y}_{h}$) maximizes the function $v(\mathcal{Y}\cup\{k\})$ over portfolios of size $h-1$ (respectively, $h$) that do not include $k$. That is, $\mathcal{Y}_{h-1}$ and $\mathcal{Y}_h$ are the optimal \emph{complements} to the singleton portfolio $\{k\}$.
\else 이제 $k \in \mathcal{X}_h$인 경우를 고려하자. 그러면 크기 $h-1$인 어떤 포트폴리오 $\mathcal{Y}_{h-1}$에 대해 $\mathcal{X}_h = \mathcal{Y}_{h-1} \cup \{k\}$으로 표현할 수 있다. $\mathcal{Y}_{h-1} \subset \mathcal{Y}_h$임을 보이면 충분하다. 정의에 따라 $\mathcal{Y}_{h-1}$ ($\mathcal{Y}_{h}$)는 크기가 $h-1$ ($h$)인 포트폴리오 중에 함수 $v(\mathcal{Y}\cup\{k\})$를 최대화한다. 다시 말해 $\mathcal{Y}_{h-1}$과 $\mathcal{Y}_h$는 각각 단일 원소 포트폴리오 $\{k\}$와 최적으로 `보완적인' 학교 집합이다. \fi

\ifen We will use the function $w(\mathcal{Y})$ to grade portfolios $\mathcal{Y} \subseteq \mathcal{C} \setminus \{k\}$ according to how well they complement $\{k\}$. To construct $w(\mathcal{Y})$, let $\tilde t_j$ denote the expected utility Alma receives from school $c_j$ \emph{given} that she has been admitted to $c_j$ and applied to $c_k$. For $j < k$, including $j = 0$, this is $\tilde t_j = (1- f_k) t_j + f_k t_k$; for $j > k $, this is $\tilde t_j = t_j$. This means that 
\else 함수 $w(\mathcal{Y})$를 이용해서 $\mathcal{Y} \subseteq \mathcal{C} \setminus \{k\}$인 포트폴리오와 $\{k\}$ 사이의 \mbox{`보완성'을} 평가하자. $w(\mathcal{Y})$를 구성하기 위해, 알마가 $c_j$에 합격한 상황에서 $c_k$에 지원했을 때 $c_j$에서 받는 조건부 기대 효용을 $\tilde t_j$라고 하자. $j = 0$을 포함한 $j < k$에 대해 이값은 $\tilde t_j = t_j (1- f_k) + t_k f_k$이며, $j > k $에 대해 $\tilde t_j = t_j$임을 알 수 있다. 따라서 \fi
\begin{equation}\label{Vyastildet}
v(\mathcal{Y}\cup\{k\}) = \sum_{j \in \{0\} \cup \mathcal{Y}} \tilde t_j p_j(\mathcal{Y}).\end{equation}
\ifen The transformation to $\tilde t$ does not change the order of the $t_j$-values. Therefore, the expression on the right side of \eqref{Vyastildet} is itself a portfolio valuation function. In the corresponding market, $t$ is replaced by $\tilde t$ and $\mathcal{C}$ is replaced by $\mathcal{C}\setminus\{k\}$. Now, we obtain $w(\mathcal{Y})$ through one more transformation: Define $\bar t_j = \tilde t_j - \tilde t_0$ so that $t_0 = 0$ and let
\else $\tilde t$로 변환하면 $t_j$의 순서가 변하지 않기 때문에 \eqref{Vyastildet}의 우변 그 자체가 포트폴리오 가치 함수이다. $t$를 $\tilde t$로, $\mathcal{C}$를 $\mathcal{C}\setminus \{k\}$로 대체하면 대응하는 시장이 된다. 이제 또 하나의 변환을 적용한다. $t_0 = 0$이 되도록 $\bar t_j = \tilde t_j - \tilde t_0$으로 정의하고 $w(\mathcal{Y})$를 다음과 같이 얻을 수 있다. \fi
\begin{equation}  \label{wYvXminusconst}
w(\mathcal{Y})
= \sum_{j \in \{0\} \cup \mathcal{Y}} \bar t_j p_j(\mathcal{Y})
= \sum_{j \in \{0\} \cup \mathcal{Y}} \tilde t_j p_j(\mathcal{Y})- \tilde t_0
= v(\mathcal{Y}\cup\{k\}) -  f_k t_k \end{equation}
\ifen where the second equality follows from Theorem \ref{assumetzerozero}. This identity says that the optimal complements to $\{k\}$, given by $\mathcal{Y}_{h-1}$ and $\mathcal{Y}_h$, are themselves optimal portfolios of size $h-1$ and $h$ for the market whose objective function is $w(\mathcal{Y})$. Since $\bar t_0 = 0$ in the latter market, the inductive hypothesis implies that $\mathcal{Y}_{h-1} \subset \mathcal{Y}_h$, which completes the proof.\footnote{We thank Yim Seho for discovering this useful transformation.}
\else 두번째 등호는 정리 \ref{assumetzerozero}에 따라 성립한다. 이 등호는, $\{k\}$와 최적으로 보완적인 $\mathcal{Y}_{h-1}$과 $\mathcal{Y}_h$는 목적함수가 $w(\mathcal{Y})$인 시장에서 각각 크기가 $h-1$과 $h$인 최적 포트폴리오임을 의미한다. 새로운 시장에서 $\bar t_0 = 0$이므로 귀납법 가설을 적용하면 $\mathcal{Y}_{h-1} \subset \mathcal{Y}_h$임을 알 수 있다. 따라서 증명이 완성된다.\footnote{이 유용한 변환을 발견한 임세호에게 감사를 표한다.} \fi
\end{proof}



\ifen \subsection{Polynomial-time solution} \else \subsection{다항 시간 해법}\fi
\ifen Applying the result above yields an efficient greedy algorithm for the optimal portfolio: Start with the empty set and add schools one at a time, maximizing $v(\mathcal{X}\cup \{k\})$ at each addition. Sorting $t$ is  $O(m \log m)$.  At each of the $h$ iterations, there are $O(m)$ candidates for $k$, and computing $v(\mathcal{X}\cup \{k\})$ is $O(h)$ using \eqref{closedformportfoliovaluationX}; therefore, the time complexity of this algorithm is $O(h^2 m + m \log m)$. 
\else 위의 결과를 적용하면 효율적인 최적 포트폴리오 탐욕 해법을 얻는다: 공집합으로 시작하고 $v(\mathcal{X}\cup \{k\})$를 최대화하는 학교를 차례대로 추가한다. $t$를 배열하는 시간을 $O(m \log m)$이다. 모든 $h$개의 반복단계에서 $k$의 후보자의 개수는 $O(m)$이며 \eqref{closedformportfoliovaluationX}을(를) 사용하면 $v(\mathcal{X}\cup \{k\})$를 계산하는 시간은 $O(h)$이다. 따라서 이 해법의 계산 시간이 $O(h^2 m + m \log m)$임을 알 수 있다.\fi
%\begin{algorithm}[H] 
%  %\DontPrintSemicolon
%\caption{Optimal portfolio algorithm for Alma’s problem when $h$ is small.} \label{algorithmforsmallh}
%\KwData{Utility values $t \in[0, \infty)^m$, admissions probabilities $f \in [0, 1]^m$, application limit $h \leq m$.}
%Index schools in ascending order by $t$\;
%$\mathcal{X} \gets \O$\;
%\For{$i=1\dots h$}
%{
%    $j \gets \argmax_k\bigl\{v(\mathcal{X}\cup\{k\}) : k \notin \mathcal{X}\bigr\}$\;
%    $\mathcal{X} \gets \mathcal{X}\cup\{j\}$ \;
%}
%\Return{$\mathcal{X}$}
%\end{algorithm}
%
%\begin{theorem}[Validity of Algorithm \ref{algorithmforsmallh}]
%Algorithm \ref{algorithmforsmallh} produces an optimal application portfolio in $O(h^2 m + m \log m)$ time.
%\end{theorem}
%\begin{proof}
%Optimality follows from Theorem \ref{nestedapplication}. Sorting $t$ is  $O(m \log m)$. At each of the $h$ iterations, there are $O(m)$ candidates for $k$, and computing $v(\mathcal{X}\cup \{k\})$ is $O(h)$ using \eqref{closedformportfoliovaluationX}; therefore, the time complexity of the main loop is $O(h^2 m)$. 
%\end{proof}
\ifen 
We reduce the computation time to $O(hm)$ by taking advantage of the transformation from the inductive step in the proof of Theorem \ref{nestedapplication}. Once school $k$ is added to $\mathcal{X}$, we remove it from the set $\mathcal{C}\setminus \mathcal{X}$ of candidates, and update the $t_j$-values of the remaining schools according to the following transformation:
\else
정리 \ref{nestedapplication} 증명의 추론 단계에서 제시한 변환을 활용하면 계산 시간을 $O(hm)$으로 감소시킬 수 있다. $\mathcal{X}$에 $k$를 추가하면, 후보자 집합인 $\mathcal{C}\setminus \mathcal{X}$에서 $k$를 제거하고 남은 학교의 $t_j$-값은 다음처럼 수정한다.
\fi
\begin{align}\label{howtotransformfj}
\bar t_j = 
\begin{cases}
(1 - f_k) t_j, \quad & t_j \leq t_k \\
t_j - f_k t_k, \quad& t_j > t_k
\end{cases}
\end{align}
\ifen
It is easy to verify that this is the composition of the two transformations (from $t$ to $\tilde t$, and from $\tilde t$ to $\bar t$) given in the proof. Now, the \emph{next} school added must be the optimal singleton portfolio in the modified market. But the optimal singleton portfolio consists simply of the school with the highest value of $f_j \bar t_j$. Therefore, by updating the $t_j$-values at each iteration according to \eqref{howtotransformfj}, we eliminate the need to compute $v(\mathcal{X})$ entirely. Moreover, this algorithm does not require the schools to be indexed in ascending order by $t_j$, which removes the $O(m\log m)$ sorting cost.
\else
이것이 증명에서 정의한 두개의 변환($t$에서 $\tilde t$로, 그리고 $\tilde t$에서 $\bar t$로)의 합성임을 쉽게 확인할 수 있다. 그러면 다음으로 추가하는 학교는 수정된 시장의 최적 단일 원소 포트폴리오가 되어야 한다. 그런데 최적 단일 원소 포트폴리오는 단순히 $f_j \bar t_j$가 가장 높은 학교로 이루어진다. 따라서 각 반복단계에서 \eqref{howtotransformfj}을(를) 이용해서 $t_j$-값을 수정하면 $v(\mathcal{X})$를 계산할 필요가 완전히 없어진다. 게다가 이 알고리즘에서 $t_j$를 배열할 필요가 없으므로 $O(m\log m)$인 배열 비용이 사라진다.
\fi

 \ifen 
The algorithm below outputs a list $\mathtt{X}$ of the $h$ schools to which Alma should apply. The schools appear in the order of entry such that when the algorithm is run with $h=m$, the optimal portfolio of size $h$ is given by $\mathcal{X}_h = \{\mathtt{X[1]}, \dots, \mathtt{X[h]}\}$. The entries of the list $\mathtt{V}$ give the valuation thereof. 
\else
아래 알고리즘은 알마가 지원하는 $h$개의 학교를 목록 $\mathtt{X}$로 출력한다. 그의 원소들은 진입하는 순서대로 등장한다. 즉, $h=m$으로 알고리즘을 돌리면 크기가 $h$인 최적 포트폴리오는 $\mathcal{X}_h = \{\mathtt{X[1]}, \dots, \mathtt{X[h]}\}$와 같다. 또한 목록 $\mathtt{V}$의 원소들은 해당 포트폴리오의 가치다.
\fi

\ifen {
\begin{algorithm}[h] 
%\DontPrintSemicolon
\caption{Optimal portfolio algorithm for Alma’s problem.} \label{algorithmforlargeh}
\KwData{Utility values $t \in(0, \infty)^m$, admissions probabilities $f \in (0, 1]^m$, application limit $h \leq m$.}
%Index schools in ascending order by $t$\;
$\mathcal{C} \gets \{1 \dots m\}$\;
$\mathtt{X, V} \gets $ empty lists\;
\For{$i=1\dots h$}
{
    $k \gets \argmax_{j \in \mathcal{C}}\{f_j t_j\}$\;
    $\mathcal{C} \gets \mathcal{C} \setminus \{k\}$\;
    $\operatorname{append!}(\mathtt{X}, k)$\;
     \lIfElse{$i=1$}{$\operatorname{append!}(\mathtt{V}, f_k t_k)$}
     {$\operatorname{append!}(\mathtt{V}, \mathtt{V[i-1]} + f_k t_k)$}
    \For{$j \in \mathcal{C}$}
	{
	\lIfElse{$t_j \leq t_k$}{$t_j \gets (1 -  f_k) t_j $}{$t_j \gets  t_j -  f_k t_k$}
	}
}
\Return{$\mathtt{X, V}$}
\end{algorithm}
} \else {
\begin{algorithm}[H] 
%\DontPrintSemicolon
\caption{알마의 문제를 위한 최적 포트폴리오 알고리즘.} \label{algorithmforlargeh}
\KwData{효용 모수 $t \in(0, \infty)^m$, 합격 확률 $f \in (0, 1]^m$, 지원 제한 $h \leq m$.}
%$t$의 순서대로 학교의 지표를 짓는다\;
$\mathcal{C} \gets \{1 \dots m\}$\;
$\mathtt{X, V} \gets $ 빈 목록\;
\For{$i=1\dots h$}
{
    $k \gets \argmax_{j \in \mathcal{C}}\{f_j t_j\}$\;
    $\mathcal{C} \gets \mathcal{C} \setminus \{k\}$\;
    $\operatorname{append!}(\mathtt{X}, k)$\;
     \lIfElse{$i=1$}{$\operatorname{append!}(\mathtt{V}, f_k t_k)$}
     {$\operatorname{append!}(\mathtt{V}, \mathtt{V[i-1]} + f_k t_k)$}
    \For{$j \in \mathcal{C}$} 
	{
	\lIfElse{$t_j \leq t_k$}{$t_j \gets (1 -  f_k) t_j $}{$t_j \gets  t_j -  f_k t_k$}
	}
}
\Return{$\mathtt{X, V}$}
\end{algorithm}
} \fi

\begin{theorem}[\ifen Validity of Algorithm \ref{algorithmforlargeh}\else 알고리즘 \ref{algorithmforlargeh}의 타당성\fi] \label{validityofalmaalgorithm}
\ifen Algorithm \ref{algorithmforlargeh} produces an optimal application portfolio for Alma's problem in $O(h m)$-time.
\else 알고리즘 \ref{algorithmforlargeh}은(는) $O(h m)$-시간 안에 알마의 문제를 위한 최적 지원 포트폴리오를 출력한다.\fi
\end{theorem}
\begin{proof}
\ifen
Optimality follows from the proof of Theorem \ref{nestedapplication}. Suppose $\mathcal{C}$ is stored as a list. Then at each of the $h$ iterations of the main loop, finding the top school costs $O(m)$, and the $t_j$-values of the remaining $O(m)$ schools are each updated in unit time. Therefore, the overall time complexity is $O(h m)$.
\else
최적성은 정리 \ref{nestedapplication}의 증명에 따라 성립한다. $\mathcal{C}$를 목록 구현으로 저장한다고 하자. 그러면 각 $h$개의 반복단계에서 최적 추가 학교를 구하는 시간은 $O(m)$이며 나머지 $O(m)$개 학교의 $t_j$-값을 각 단위 시간으로 수정할 수 있다. 따라서 전체 시간 복잡도가 $O(h m)$이다.
\fi
\end{proof}

\ifen 
It is also possible to store $\mathcal{C}$ as a binary max heap rather than a list. The heap is ordered according to the criterion $i \geq j \iff f_i t_i \geq f_j t_j$, and by draining the heap and reheapifying at the end of each iteration, the computation time remains $O(hm)$. However, in our numerical experiments, whose results are reported in Section \ref{numericalexperiments},
we found the list implementation to be much faster, because it is possible to identify the entering school $k$ as the utility parameters are updated, which all but eliminates the cost of the $\argmax\{\}$ operation. 
\else
$\mathcal{C}$는 목록 대신 이진 최대 힙 구현으로 저장하는 방법도 고려한다. 단, 힙의 순서는 $i \geq j \iff f_i t_i \geq f_j t_j$의 조건으로 정의하며, 각 반복단계의 마지막 단계에서 힙을 비우고 다시 힙화(heapify)하면 $O(hm)$ 계산 시간을 유지할 수 있다. 그러나 (\ref{numericalexperiments}절에서 결과를 제시할) 수리 실험에서 목록 구현으로 구성한 알고리즘이 더 빨랐다. 효용 모수를 수정하면서 $k$를 구함으로 $\argmax\{\}$ 연산의 계산 비용을 거의 제거할 수 있기 때문이다.
\fi


\ifen \subsection{Properties of the optimal portfolios} \else\subsection{최적 포트폴리오의 성질} \fi
\ifen The nestedness property implies that Alma's expected utility is a discretely concave function of $h$.
\else 포함 사슬 관계 성질은 알마의 기대 효용이 $h$의 이산 오목 함수임을 의미한다.\fi

\begin{theorem}[\ifen Optimal portfolio valuation concave in $h$\else 최적 포트폴리오 가치의 $h$-오목성\fi] \label{concavityinh}
\ifen For $h = 2 \dots (m-1)$,
\else $h = 2 \dots (m-1)$에 대해,\fi
\begin{equation}v(\mathcal{X}_h) - v(\mathcal{X}_{h-1}) \geq v(\mathcal{X}_{h+1}) - v(\mathcal{X}_{h}).\end{equation} 
\end{theorem}
\begin{proof}
\ifen We will prove the equivalent expression $2 v(\mathcal{X}_h) \geq v(\mathcal{X}_{h+1}) + v(\mathcal{X}_{h-1})$. Applying Theorem \ref{nestedapplication}, we write $\mathcal{X}_h = \mathcal{X}_{h-1} \cup\{j\}$ and $\mathcal{X}_{h+1} = \mathcal{X}_{h-1} \cup\{j, k\}$. If $t_k \leq t_j$, then 
\else $2 v(\mathcal{X}_h) \geq v(\mathcal{X}_{h+1}) + v(\mathcal{X}_{h-1})$ 같은 동등한 부등식을 증명하자. 정리 \ref{nestedapplication}을(를) 적용하면 $ \mathcal{X}_h = \mathcal{X}_{h-1} \cup\{j\}$ 그리고 $\mathcal{X}_{h+1} = \mathcal{X}_{h-1} \cup\{j, k\}$으로 표현할 수 있다. $t_k \leq t_j$인 경우, \fi
\begin{align}
\begin{split}
2 v(\mathcal{X}_h) &= v(\mathcal{X}_{h-1} \cup\{j\}) + v(\mathcal{X}_{h-1} \cup\{j\}) \\
&\geq v(\mathcal{X}_{h-1} \cup\{k\}) + v(\mathcal{X}_{h-1} \cup\{j\}) \\
&= v(\mathcal{X}_{h-1} \cup\{k\}) + (1 - f_j) v(\mathcal{X}_{h-1}) + f_j \operatorname{E}[\max\{t_j, X_{h-1}\}] \\
&= v(\mathcal{X}_{h-1} \cup\{k\}) - f_j v(\mathcal{X}_{h-1}) + f_j \operatorname{E}[\max\{t_j, X_{h-1}\}] + v(\mathcal{X}_{h-1})  \\
&\geq v(\mathcal{X}_{h-1} \cup\{k\})  - f_j v(\mathcal{X}_{h-1}\cup\{k\}) + f_j \operatorname{E}[\max\{t_j, X_{h-1}\}]+ v(\mathcal{X}_{h-1})\\
&= (1 - f_j) v(\mathcal{X}_{h-1} \cup\{k\})  + f_j \operatorname{E}[\max\{t_j, X_{h-1}\}]+ v(\mathcal{X}_{h-1})\\
&=  v(\mathcal{X}_{h-1} \cup\{j, k\}) + v(\mathcal{X}_{h-1})\\
&=  v(\mathcal{X}_{h+1}) + v(\mathcal{X}_{h-1}).
\end{split} 
\end{align}
\ifen The first inequality follows from the optimality of $\mathcal{X}_h$, while the second follows from the fact that adding $k$ to $\mathcal{X}_{h-1}$ can only increase its valuation.
\else 첫번째 부등식은 $\mathcal{X}_h$의 최적성에 따르며, 두번째 부등식은 $\mathcal{X}_{h-1}$에 $j$를 더하면 가치가 증가할 수 밖에 없기 때문이다.\fi

\ifen If $t_k \geq t_j$, then the steps are analogous:
\else  $t_k \geq t_j$인 경우는 유사하다:\fi
\begin{align}
\begin{split}
2 v(\mathcal{X}_h) &= v(\mathcal{X}_{h-1} \cup\{j\}) + v(\mathcal{X}_{h-1} \cup\{j\}) \\
&\geq v(\mathcal{X}_{h-1} \cup\{k\}) + v(\mathcal{X}_{h-1} \cup\{j\}) \\
&= (1 - f_k) v(\mathcal{X}_{h-1}) + f_k \operatorname{E}[\max\{t_k, X_{h-1}\}] +  v(\mathcal{X}_{h-1} \cup\{j\})  \\
&= v(\mathcal{X}_{h-1}) - f_k  v(\mathcal{X}_{h-1}) + f_k \operatorname{E}[\max\{t_k, X_{h-1}\}] +  v(\mathcal{X}_{h-1} \cup\{j\})  \\
&\geq v(\mathcal{X}_{h-1}) - f_k  v(\mathcal{X}_{h-1}\cup\{j\}) + f_k \operatorname{E}[\max\{t_k, X_{h-1}\}] +  v(\mathcal{X}_{h-1} \cup\{j\})  \\
&= v(\mathcal{X}_{h-1}) + (1 - f_k) v(\mathcal{X}_{h-1}\cup\{j\}) + f_k \operatorname{E}[\max\{t_k, X_{h-1}\}]  \\
&= v(\mathcal{X}_{h-1}) + v(\mathcal{X}_{h-1} \cup\{j, k\})
\end{split}\\
&= v(\mathcal{X}_{h-1})  + v(\mathcal{X}_{h+1}) \qedhere
\end{align}
\end{proof}

\ifen
It follows that when $\mathcal{X}_h$ is the optimal $h$-portfolio for a given market, $v(\mathcal{X}_h)$ is $O(h)$. Example \ref{tightexampleforoneoverhopt}, in which $v(\mathcal{X}_h)$ can be made arbitrarily close to $h$, establishes the tightness of this bound.
\else
위 결과는 $\mathcal{X}_h$가 어떤 시장의 최적 $h$-포트폴리오일 때, $v(\mathcal{X}_h)$가 $O(h)$ 함수라고 의미한다. 예 \ref{tightexampleforoneoverhopt}에서 $v(\mathcal{X}_h)$를 $h$에 임의로 가깝게 조정할 수 있으므로 이 상한이 타이트함을 알 수 있다.
\fi

%To wrap up, we provide an example showing that if the entries of $Z$ are dependent, then the optimal solution may violate the nestedness property of Theorem \ref{nestedapplication}.
%\begin{example}
%Let $t = (3, 3, 4)$, $Z_1 \sim \operatorname{Bernoulli}(0.5)$, $Z_2 = 1 - Z_1$,  and $Z_3 \sim \operatorname{Bernoulli}(0.5)$. Then it is easy to verify that the unique optimal portfolios are $\mathcal{X}_1 = \{3\}$ and $\mathcal{X}_2 = \{1, 2\}$. 
%\end{example}

\ifen \subsection{A small example} \else \subsection{작은 예} \fi
\ifen 
Let us consider a fictional admissions market consisting of $m=8$ schools. The school data, along with the optimal solutions for each $h \leq m$, appear in Table \ref{planetsdata}.
\else 
$m = 8$개의 학교로 구성된 가상 입학 시장을 고려하자. 학교 자료와 각 $h \leq m$에 대응하는 최적해는 표 \ref{planetsdata}에서 나타난다.
\fi

\ifen
Below are shown the first several iterations of Algorithm \ref{algorithmforlargeh}. The values of $f_j$, $t_j$, and their product are recorded only for the schools remaining in $\mathcal{C}$. $f * t$, where $(f * t)_j = f_j t_j$, denotes the entrywise product of $f$ and $t$. The school added at each iteration, underlined, is the one whose $f_j t_j$-value is greatest.
\else
아래에서 알고리즘 \ref{algorithmforlargeh}의 몇 반복단계가 나타난다. $f_j$, $t_j$, 그리고 그 곱의 값은 $\mathcal{C}$에 남아 있는 학교에 해당하는 값만 기록한다. $(f * t)_j = f_j t_j$로 정의된 $f * t$는 $f$와 $t$의 원소 당 곱을 의미한다. 각 반복단계에서 최적해에 추가하는 학교는 $f_j t_j$-값이 가장 높은 학교이며 이를 밑줄로 강조한다.
\fi
\newcommand{\Iteration}{\ifen Iteration~\else 반복단계~\fi}
\begin{align*}
\text{\Iteration 1:}
&&C &= \{1, 2, 3, 4, 5, 6, 7, 8\} \\
&&f &= \{0.39, 0.33, 0.24, 0.24, 0.05, 0.03, 0.1, 0.12\} \\
&&t &= \{200, 250, 300, 350, 400, 450, 500, 550\} \\
&&f * t &= \{78.0, 82.5, 72.0, \underline{84.0}, 20.0, 13.5, 50.0, 66.0\} 
~~\tag*{\(\implies \mathcal{X}_3 = \{4\} \)}\\
\text{\Iteration 2:}
&&C &= \{1, 2, 3, 5, 6, 7, 8\} \\
&&f &= \{0.39, 0.33, 0.24, 0.05, 0.03, 0.1, 0.12\} \\
&&t &= \{152, 190, 228, 316, 366, 416, 466\} \\
&&f * t &= \{59.28, \underline{62.7}, 54.72, 15.8, 10.98, 41.6, 55.92\} 
~~\tag*{\(\implies \mathcal{X}_3 = \{4, 2\} \)}\\
\text{\Iteration 3:}
&&C &= \{1, 3, 5, 6, 7, 8\} \\
&&f &= \{0.39, 0.24, 0.05, 0.03, 0.1, 0.12\} \\
&&t &= \{101.84, 165.3, 253.3, 303.3, 353.3, 403.3\} \\
&&f * t &= \{39.718, 39.672, 12.665, 9.099, 35.33, \underline{48.396}\} 
~~\tag*{\(\implies \mathcal{X}_3 = \{4, 2, 8\} \)}\\
&&&\cdots\\
\text{\Iteration 8:}
&&C &= \{6\}, f = \{0.03\}, t = \{177.622\}, f * t= \{\underline{5.329}\}
~~\tag*{\(\implies \mathcal{X}_3 = \{4, 2, 8, 1, 7, 3, 5, 6\} \)}
\end{align*}
\ifen 
The output of the algorithm is $\mathtt{X} = [4, 2, 8, 1, 7, 3, 5, 6]$, and the optimal $h$-portfolio consists of its first $h$ entries. The ``priority'' column of Table \ref{planetsdata} shows the inverse permutation of $\mathtt{X}$, which is the minimum value of $h$ for which the school is included in the optimal portfolio. Figure \ref{planetsplot} shows the value of the optimal portfolio as a function of $h$. The concave shape of the plot suggests the result of Theorem \ref{concavityinh}. 
\else
알고리즘의 출력은 $\mathtt{X} = [4, 2, 8, 1, 7, 3, 5, 6]$이며 최적 $h$-포트폴리오는 그의 첫 $h$개의 원소로 이루어진다. 표 \ref{planetsdata}에서 등장하는 ``지원 순위'' 자료는 $\mathtt{X}$의 역순열(inverse permutation)이며 이는 해당 학교가 최적 포트폴리오에 포함되는 최소한 $h$-값을 의미한다. 그림 \ref{planetsplot}은 최적 포트폴리오의 가치를 $h$의 함수로 나타낸다. 곡선의 오목성은 정리 \ref{concavityinh}의 결과를 시사한다.
\fi




\begin{table}[h!] \centering
\small
\begin{tabular}{r|lcccc}
\ifen\textbf{Index $j$} & \textbf{School $c_j$} & \textbf{Utility $t_j$} & \textbf{Admit prob. $f_j$} & \textbf{Priority} & \textbf{$v(\mathcal{X}_h)$} \\ \hline
\else 
\textbf{지표 $j$} & \textbf{학교 $c_j$} & \textbf{효용 $t_j$} & \textbf{합격 확률 $f_j$} & \textbf{지원 순위} & \textbf{$v(\mathcal{X}_h)$} \\ \hline  \fi
\\[-.75em]
1 & \ifen Mercury University   \else  수성대       \fi        & 200 & 0.39 & 4   & 230.0   \\
2 & \ifen Venus University     \else  금성대       \fi        & 250 & 0.33 & 2   & 146.7  \\
3 & \ifen Mars University      \else  화성대       \fi        & 300 & 0.24 & 6   & 281.5  \\
4 & \ifen Jupiter University   \else  목성대       \fi        & 350 & 0.24 & 1   & \phantom{0}84.0  \\
5 & \ifen Saturn University    \else  토성대       \fi        & 400 & 0.05 & 7   & 288.8  \\
6 & \ifen Uranus University    \else  천왕성대     \fi        & 450 & 0.03 & 8   & 294.1  \\
7 & \ifen Neptune University   \else  해왕성대     \fi        & 500 & 0.10 & 5   & 257.7  \\
8 & \ifen Pluto College        \else  명왕성대       \fi        & 550 & 0.12 & 3   & 195.1              
\end{tabular}
\caption{\label{planetsdata} \normalsize
\ifen College data and optimal application portfolios for a fictional market with $m=8$ schools. By the nestedness property (Theorem \ref{nestedapplication}), the optimal portfolio when the application limit is $h$ consists of the $h$ schools having priority $h$ or less.
\else
$m=8$개의 학교로 이루어진 가상 입학 시장의 대학교 자료와 최적 지원 포트폴리오. 포함 사슬 관계 성질(정리 \ref{nestedapplication})에 따라, 지원 제한이 $h$일 때 최적 포트폴리오는 지원 순위가 $h$ 이하인 $h$개의 학교로 구성된다.
\fi}
\end{table}


\begin{figure}[h!] 
 \centering
 \includegraphics[width=0.95\textwidth]{./plots/h_v-example.pdf}
  \caption{  \label{planetsplot}
  \ifen Application limit $h$ versus the optimal portfolio valuation $v^* = v(\mathcal{X}_h)$ in a fictional market with $m=8$ schools. The concave shape suggests the result of Theorem \ref{concavityinh}. 
  \else $m=8$개의 학교로 구성된 가상 입학 시상에서, 각 지원 제한 $h$에 해당하는 최적 포트폴리오의 가치 $v^* = v(\mathcal{X}_h)$. 곡선의 오목성은 정리 \ref{concavityinh}의 결과를 시사한다.\fi}
\end{figure}








%\pagebreak
\ifen \section{Heterogeneous application costs} \else\section{동일하지 않은 지원 비용} \fi\label{hetappcosts}
\ifen
Now we turn to the more general problem in which the constant $g_j$ represents the \emph{cost} of applying to $c_j$ and the student, whom we now call Ellis, has a \emph{budget} of $H$ to spend on college applications.  Applying Theorem \ref{assumetzerozero}, we assume $t_0 = 0$ throughout.
\else
이제 $g_j$가 $c_j$에 지원하는 비용을 나타내며 학생이 지원에 쓸 수 있는 예산이 $H$인 일반적인 문제를 고려한다. 이 문제를 풀고자 하는 학생을 엘리스라고 부르자. 본 절 내내 정리 \ref{assumetzerozero}을(를) 적용해서 $t_0 = 0$임을 가정하자.
\fi

\begin{problem}[\ifen Ellis's problem\else 엘리스의 문제\fi]
\ifen
Ellis's optimal college application portfolio is given by the solution to the following combinatorial optimization problem.
\else 
엘리스의 최적 대학 지원 포트폴리오는 다음 조합 최적화 문제의 최적해이다.
\fi
\begin{align}
\begin{split}
\text{maximize}\quad &  v(\mathcal{X}) = \sum_{j\in
%\{0\}\cup
\mathcal{X}} \Bigl(f_j t_j \prod_{\substack{i \in \mathcal{X}: \\ i > j}} (1 - f_{i}) \Bigr)\\
\text{subject to}\quad & \mathcal{X}\subseteq\mathcal{C},~~\sum_{j \in \mathcal{X}} g_j \leq H 
\end{split}
\end{align}
\end{problem}

\ifen
In this section, we show that this problem is NP-complete, then provide three algorithmic solutions: an exact branch-and-bound routine, an exact dynamic program, and a fully polynomial-time approximation scheme (FPTAS).
\else
본 절에서 이 문제가 NP-complete임을 보이고 3가지 해법을 제시한다: 정확한 분지한계법 해법, 정확한 동적 계획 해법, 그리고 완전 다항 시간 근사 해법 (fully polynomial-time approximation scheme, FPTAS).
\fi

\ifen \subsection{NP-completeness} \else \subsection{NP-completeness}\fi
\ifen
The optima for Ellis's problem are not necessarily nested, nor is the number of schools in the optimal portfolio necessarily increasing in $H$. For example, if
$f = (0.5, 0.5, 0.5)$, $t = (1, 1, 219)$, and $g = (1, 1, 3)$,
then it is evident that the optimal portfolio for $H = 2$ is $\{1, 2\}$ while that for $H = 3$ is $\{3\}$. In fact, Ellis’s problem is NP-complete, as we will show by a transformation from the binary knapsack problem, which is known to be NP-complete (Garey and Johnson 1979, \S\,3.2.1).
\else
엘리스 문제의 최적해는 필수적으로 포함 사슬 관계를 가지지 않으며 최적 포트폴리오에 속한 학교의 개수는 $H$에 대해 감소할 수도 있다. 예를 들어
$f = (0.5, 0.5, 0.5)$, $t = (1, 1, 219)$, 그리고 $g = (1, 1, 3)$이면 $H = 2$에 대응하는 최적해가 $\{1, 2\}$이며 $H = 3$에 대응하는 최적해는 $\{3\}$임을 쉽게 알 수 있다. 사실은 엘리스의 문제가 NP-complete이며 이를 이진 배낭 문제에서의 변환을 통해 증명할 수 있다. 배낭 문제의 NP-completeness가 이미 알려져 있다 (Garey and Johnson 1979, \S\,3.2.1).
\fi


\begin{problem}[\ifen Decision form of knapsack problem\else 배낭 문제의 결정 형태\fi]
\ifen 
An \emph{instance} consists of a set $\mathcal{B}$ of $m$ objects, utility values $u_j \in \mathbb{N}$ and weight $w_j \in \mathbb{N}$ for each $j \in \mathcal{B}$, and target utility $U\in \mathbb{N}$ and knapsack capacity $W\in \mathbb{N}$. The instance is called a \emph{yes-instance} if and only if there exists a set $\mathcal{B’} \subseteq \mathcal{B}$ having $\sum_{j \in \mathcal{B’}} u_j \geq U$ and  $\sum_{j \in \mathcal{B’}} w_j \leq W$.
\else
`인스턴스'는 $m$개 상품으로 이루어진 집합 $\mathcal{B}$, 각 $j \in \mathcal{B}$에 대한 효용값 $u_j \in \mathbb{N}$와 무게 $w_j \in \mathbb{N}$, 목적 효용 $U\in \mathbb{N}$, 그리고 배낭 용량 $W\in \mathbb{N}$로 구성된다. 인스턴스가 `예-인스턴스'가 될 필수충분 조건은 $\sum_{j \in \mathcal{B’}} u_j \geq U$와  $\sum_{j \in \mathcal{B’}} w_j \leq W$를 만족하는 집합 $\mathcal{B’} \subseteq \mathcal{B}$가 존재하는 것이다.
\fi
\end{problem}

\begin{problem}[\ifen Decision form of Ellis's problem\else 엘리스 문제의 결정 형태\fi] \label{ellisdecisionform}
\ifen
An \emph{instance} consists of an instance of Ellis’s problem and a target valuation $V$. The instance is called a \emph{yes-instance} if and only if there exists a portfolio $\mathcal{X} \subseteq \mathcal{C}$ having $v(\mathcal{X}) \geq V$ and  $\sum_{j \in \mathcal{X}} g_j \leq H$.
\else
`인스턴스'는 엘리스 문제의 인스턴스와 목적 포트폴리오 가치 $V$로 구성된다. 인스턴스가 `예-인스턴스'가 될 필수충분 조건은 $v(\mathcal{X}) \geq V$와 $\sum_{j \in \mathcal{X}} g_j \leq H$를 만족하는 포트폴리오 $\mathcal{X} \subseteq \mathcal{C}$가 존재하는 것이다.
\fi
\end{problem}

\begin{theorem}
\ifen
The decision form of Ellis’s problem is NP-complete.
\else
엘리스 문제의 결정 형태는 NP-complete하다.
\fi
\end{theorem}

\begin{proof}
\ifen It is obvious that the problem is in NP.
\else 문제가 NP에 속하는 것은 자명하다.\fi

\ifen
Consider an instance of the knapsack problem, and we will construct an instance of Problem \ref{ellisdecisionform} that is a yes-instance if and only if the corresponding knapsack instance is a yes-instance. Without loss of generality, we may assume that the the objects in $\mathcal{B}$ are indexed in increasing order of $u_j$, that each $u_j >0$, and that each $w_j \leq W$. 
\else
임의의 배낭 문제 인스턴스를 택하고, 예-인스턴스 여부가 동치인 문제 \ref{ellisdecisionform}의 인스턴스를 만들자. 일반성을 잃지 않고 $\mathcal{B}$에 속한 상품이 $u_j$가 증가하는 순서대로 배열되며 모든 $u_j >0$이고 $w_j \leq W$임을 가정할 수 있다.
\fi

\ifen
Let $U_{\mathrm{max}} = \sum_{j \in \mathcal{B}} u_j$ and $\delta = {1} /{m U_{\mathrm{max}}} > 0$, and construct an instance of Ellis’s problem with $\mathcal{C} = \mathcal{B}$, $H = W$, all $f_j = \delta$, and each $t_j = u_j / \delta$. Clearly, $\mathcal{X} \subseteq \mathcal{C}$ is feasible for Ellis’s problem if and only if it is feasible for the knapsack instance. Now, we observe that for any nonempty $\mathcal{X}$,
\else
$U_{\mathrm{max}} = \sum_{j \in \mathcal{B}} u_j$와 $\delta = {1} /{m U_{\mathrm{max}}} > 0$일 때, $\mathcal{C} = \mathcal{B}$, $H = W$,  모든 $f_j = \delta$, 그리고 각 $t_j = u_j / \delta$인 엘리스 문제의 인스턴스를 고려하자. $\mathcal{X} \subseteq \mathcal{C}$가 엘리스 문제의 가능해가 되는 것은 배낭 문제 인스턴스의 가능해가 되는 것과 동치임을 쉽게 알 수 있다. 그러면 공집합이 아닌 임의의 $\mathcal{X}$ 에 대해,
\fi
\begin{align}
\begin{split}
\sum_{j \in \mathcal{X}} u_j &=  \sum_{j \in \mathcal{X}} f_j t_j
> \sum_{j \in \mathcal{X}} \Bigl( f_j t_j \prod_{\substack{j’ \in \mathcal{X}: \\ j' > j}} (1 - f_{j’}) \Bigr)
= v(\mathcal{X}) \\
&= \sum_{j \in \mathcal{X}} \Bigl( u_j  \prod_{\substack{j’ \in \mathcal{X}: \\ j' > j}} (1 - \delta) \Bigr)
\geq (1 - \delta)^m \sum_{j \in \mathcal{X}} u_j \\
&\geq (1 - m\delta) \sum_{j \in \mathcal{X}} u_j 
\geq \sum_{j \in \mathcal{X}} u_j  - m\delta U_{\mathrm{max}}
= \sum_{j \in \mathcal{X}} u_j  - 1.
\end{split}
\end{align}
\ifen
This means that the utility of an application portfolio $\mathcal{X}$ in the corresponding knapsack instance is the smallest integer greater than $v( \mathcal{X})$. That is, $\sum_{j \in \mathcal{X}} u_j \geq U$ if and only if $v(\mathcal{X}) \geq U -1$. Taking $V = U-1$ completes the transformation and concludes the proof. 
\else
이는 지원 포트폴리오 $\mathcal{X}$가 해당 배낭 문제에서 일으키는 효용이 $v( \mathcal{X})$보다 크면서 가장 작은 정수임을 의미한다. 즉, $\sum_{j \in \mathcal{X}} u_j \geq U$가 성립할 필수충분 조건은 $v(\mathcal{X}) \geq U -1$이다. $V = U-1$으로 정의해서 변환을 완성하면 증명이 완료된다.
\fi
\end{proof}

\ifen 
An intuitive extension of the greedy algorithm for Alma's problem is to iteratively add to $\mathcal{X}$ the school $k$ for which $[ v(\mathcal{X}\cup\{k\}) - v(\mathcal{X}) ] / g_k$ is largest. However, the construction above shows that the objective function of Ellis's problem can approximate that of a knapsack problem with arbitrary precision. Therefore, in pathological examples such as the following, the greedy algorithm can achieve an arbitrarily small approximation ratio. 
\else
알마 문제를 위한 탐욕 해법의 직관적인 확장은 $[ v(\mathcal{X}\cup\{k\}) - v(\mathcal{X}) ] / g_k$-값이 가장 높은 학교 $k$를  $\mathcal{X}$에 차례대로 추가하는 것이다. 그러나 위에서 도출한 변환은 엘리스 문제의 목적함수를 배낭 문제의 목적함수의 원하는 만큼 정확한 근사로 만들 수 있음을 의미한다. 따라서 다음 같은 병례에서 탐욕 해법은 임의로 낮은 근사 비율을 일으킬 수 있다.
\fi
\begin{example}
\ifen
Let $t = (10, 2021)$, $f = (1, 1)$, $g = (1, 500)$, and $H = 500$. Then the greedy approximation algorithm produces the clearly inoptimal solution $\mathcal{X} = \{1\}$. 
\else
 $t = (10, 2021)$, $f = (1, 1)$, $g = (1, 500)$, 그리고 $H = 500$이라고 하자. 그러면 탐욕 해법은 $\mathcal{X} = \{1\}$을 출력하며 이는 분명히 최적해가 아니다.
\fi
\end{example} 
% as the following example suggests ...The construction above shows that the objective function of Ellis's problem can approximate that of a knapsack problem with arbitrary precision, and this algorithm

\ifen \subsection{Branch-and-bound algorithm} \else \subsection{분지한계법} \fi
\ifen 
A traditional approach to integer optimization problems is the branch-and-bound framework, which generates subproblems in which the values of one or more decision variables are fixed and uses an upper bound on the objective function to exclude, or \emph{fathom,} branches of the decision tree that cannot yield a solution better than the best solution on hand (Martello and Toth 1990; Kellerer et al. 2004). In this subsection, we present an integer formulation of Ellis's problem and a linear program (LP) that bounds the objective value from above. We tighten the LP bound for specific subproblems by reusing the conditional transformation of the $t_j$-values from Algorithm \ref{algorithmforlargeh}. A branch-and-bound routine emerges naturally from these ingredients.
\else
정수 최적화의 고전적인 기법 중 분지한계법(branch and bound)이 있다. 이는 하나 이상의 결정 변수를 고정시키고 해당 부문제를 탐색하는 해법이며, 목적함수의 상한(bound)을 활용해서 기존 해보다 좋은 해를 생성할 수 없는 결정 나무의 가지(branch)를 제외시켜 결정 공간을 줄인다 (Martello and Toth 1990; Kellerer 외 2004). 본 항에서, 엘리스 문제의 정수 모형과 그의 상한이 되는 선형 계획을 제시한다. 알고리즘 \ref{algorithmforlargeh}에서 개발한 $t_j$-값의 변환을 활용해서 부문제의 선형 완화 문제에 의한 상한을 더 타이트하게 만든다. 이 기반으로 분지한계법 알고리즘을 도출한다.
\fi

\ifen
To begin, let us characterize the portfolio $\mathcal{X}$ as the binary vector $x \in \{0, 1\}^m$, where $x_j = 1 $ if and only if $j \in \mathcal\{X\}$. Then it is not difficult to see that Ellis's problem is equivalent to the following integer nonlinear program. 
\else
우선 포트폴리오 $\mathcal{X}$를 이진 특성 벡터 $x \in \{0, 1\}^m$로 표현하자. 단, $x_j = 1 $인 것은 $j \in \mathcal\{X\}$과 동치다. 그러면 엘리스의 문제가 다음 비선형 정수 최적화 문제와 동등함을 볼 수 있다.
\fi
\begin{problem}[\ifen Integer NLP for Ellis's problem\else 엘리스의 문제를 위한 비선형 정수 계획\fi] \label{integernlp}
\begin{align}
\begin{split}
\text{maximize}\quad &  v(x) = \sum_{j=1}^m \Bigl(f_j t_j  x_j \prod_{i > j} (1 - f_{i} x_i) \Bigr)\\
\text{subject to}\quad & \sum_{j=1}^m g_j x_j \leq H, ~~ x_i \in \{0, 1\}^m
\end{split}
\end{align}
\end{problem}
\ifen
Since the product in $v(x)$ does not exceed one, the following LP relaxation is an upper bound on the valuation of the optimal portfolio.
\else
$v(x)$에서 등장하는 곱은 1을 넘을 수 없으므로 다음 선형 완화 문제는 최적 포트폴리오 가치의 상한이 된다.
\fi
\begin{problem}[\ifen LP relaxation for Ellis's problem\else 엘리스의 문제를 위한 선형 완화 문제\fi] \label{LPrelaxation}
\begin{align}
\begin{split}
\text{maximize}\quad &  v_{\mathrm{LP}}(x) = \sum_{j=1}^m  f_j t_j x_j \\
\text{subject to}\quad & \sum_{j=1}^m g_j x_j \leq H, ~~ x \in [0, 1]^m
\end{split}
\end{align}
\end{problem}
\ifen
Problem \ref{LPrelaxation} is a continuous knapsack problem, which is easily solved in $O(m \log m)$-time by the following greedy algorithm: Start with $x = \mathbf{0}$. While $H > 0$, select the school $j$ for which $f_j t_j / g_j$ is highest, set $x_j \gets \min\{1, H / g_j\}$, and set $H \gets H - g_j$ (Dantzig 1957). Balas and Zemel (1980, \S\,2) provide an $O(m)$ algorithm. 
\else
문제 \ref{LPrelaxation}은(는) ``연속 배낭 문제''라고 불리며 다음 탐욕 알고리즘을 적용하면 $O(m \log m)$-시간 안에 쉽게 풀 수 있다: $x = \mathbf{0}$로 초기화한다. $H > 0$임이 성립하는 동안, $f_j t_j / g_j$-값이 가장 높은 학교 $j$를 택한다. $x_j \gets \min\{1, H / g_j\}$ 그리고 $H \gets H - g_j$로 수정해서 반복한다 (Dantzig 1957).  $O(m)$ 알고리즘도 알려져 있다 (Balas와 Zemel 1980, \S\,2).
\fi

\ifen 
In our branch-and-bound framework, a \emph{node} is characterized by a three-way partition of schools $\mathcal{C}= \mathcal{I} \cup \mathcal{O} \cup \mathcal{N}$ satisfying $\sum_{j \in \mathcal{I}} g_j \leq H$. $\mathcal{I}$ consists of schools that are ``in'' the application portfolio ($x_j = 1$), $\mathcal{O}$ consists of those that are ``out'' ($x_j = 0$), and $\mathcal{N}$ consists of those that are ``negotiable.'' 
%This partition induces a constant $\gamma$, transformed $t_j$-values $\bar t$, the residual budget $\mathcal{H}$, and a set $\mathcal{L}$ of pointers to the node's children, if any.
The choice of partition induces a pair of subproblems. The first subproblem is an instance of Problem \ref{integernlp}, namely
\else
본 연구의 분지한계법 설계에서, `마디'(node)는 학교를 세 군으로 나눈 분할 $\mathcal{C}= \mathcal{I} \cup \mathcal{O} \cup \mathcal{N}$로 묘사한다. 단, $\mathcal{I}$는 $\sum_{j \in \mathcal{I}} g_j \leq H$을 만족한다. $\mathcal{I}$는 지원 포트폴리오에 속한 학교(`in': $x_j = 1$), $\mathcal{O}$는 속하지 않은 학교(`out': $x_j = 0$), 그리고 $\mathcal{N}$은 미결의 학교(`negotiable')로 이루어진다. 분할이 결정되면 부문제의 한 쌍이 결정해진다. 첫번째 부문제는 다음 같은 문제 \ref{integernlp}의 인스턴스다.
\fi
\begin{align} \label{nodenlpsubproblem}
\begin{split}
\text{maximize}\quad &  v(x) = \gamma + \sum_{j \in \mathcal{N}} \Bigl(f_j \bar t_j x_j \prod_{\substack{i \in \mathcal{N}:\\i > j}} (1 - f_{i} x_i) \Bigr)\\
\text{subject to}\quad & \sum_{j \in \mathcal{N}} g_j x_j \leq \bar H; ~~ x_j \in \{0, 1\},~~j \in \mathcal{N}.
\end{split}
\end{align}
\ifen The second is the corresponding instance of Problem \ref{LPrelaxation}:
\else 두번째 부문제는 대응하는 문제 \ref{LPrelaxation} 인스턴스다.\fi
\begin{align} \label{nodelprelaxation}
\begin{split}
\text{maximize}\quad &  w_{\mathrm{LP}}(x)= \gamma + \sum_{j \in \mathcal{N}}  f_j \bar t_j  x_j \\
\text{subject to}\quad & \sum_{j \in \mathcal{N}} g_j x_j \leq \bar H; ~~ x_j \in [0, 1],~~j \in \mathcal{N}
\end{split}
\end{align}
\ifen
In both subproblems, $\bar H = H - \sum_{j\in \mathcal{I}} g_j$ denotes the residual budget. The parameters $\gamma$ and $\bar t$ are obtained by iteratively applying the transformation \eqref{howtotransformfj} to the schools in $\mathcal{I}$. For each $j\in \mathcal{I}$,  we increment $\gamma$ by the current value of $f_j \bar t_j$, eliminate $j$ from the market, and update the remaining $\bar t_j$-values using \eqref{howtotransformfj}. (An example is given below.)
\else
각 부문제에서 $\bar H = H - \sum_{j\in \mathcal{I}} g_j$는 잔여 예산을 의미한다. $\mathcal{I}$에 속한 학교에 \eqref{howtotransformfj}의 변환을 적용해서 모수 $\gamma$와 $\bar t$를 얻을 수 있다. 즉, 각 $j\in \mathcal{I}$에 대해 $\gamma$를 $f_j \bar t_j$ 만큼 증가시키고, 시장에서 $j$를 소거하고, \eqref{howtotransformfj}에 따라 남은 $\bar t_j$-값을 수정한다. (아래에서 예를 제시한다.)
\fi

\ifen 
Given a node $n  = (\mathcal{I}, \mathcal{O}, \mathcal{N})$, its children are generated as follows. Every node has two, one, or zero children. In the typical case, we select a school $j \in \mathcal{N}$ for which $g_j \leq \bar H$ and generate one child by moving $j$ to $\mathcal{I}$, and another child by moving $j$ it to $\mathcal{O}$. Equivalently, we set $x_j = 1$ in one child and $x_j = 0$ in the other. In principle, any school can be chosen for $j$, but as a greedy heuristic, we choose the school for which the ratio $f_j \bar t_j / g_j$ is highest.  Notice that this method of generating children ensures that each node's $\mathcal{I}$-set differs from its parent's by at most a single school, so the constant $\gamma$ and transformed $\bar t_j$-values for the new node can be obtained by a single application of \eqref{howtotransformfj}. 
\else
마디  $n  = (\mathcal{I}, \mathcal{O}, \mathcal{N})$이 주어질 때, 그의 새끼 마디를 다음처럼 생성한다. 모든 마디에는 2, 1, 혹은 0개의 새끼가 있다. 전형적인 경우에서, $g_j \leq \bar H$를 만족하는 학교 $j \in \mathcal{N}$ 선택한다. $j$를 $\mathcal{I}$로 이동시켜서 한 새끼를 얻고, $j$를 $\mathcal{O}$로 이동시켜서 다른 새끼를 얻는다. 즉, 한 새끼 마디에서 $x_j = 1$로 고정시키도 다른 새끼 마디에서 $x_j = 0$으로 고정시킨다. 일반적으로 $j$는 임의의 학교가 될 수 있지만 탐욕적인 휴리스틱으로 $f_j \bar t_j / g_j$의 비율이 가장 높은 학교를 선택한다. 이런 식으로 새끼를 생성하면 각 마디의 $\mathcal{I}$-집합은 자신의 어미 마디의 $\mathcal{I}$-집합과 최대 한 학교로만 다르다. 따라서 새로운 마디를 생성할 때, \eqref{howtotransformfj}을(를) 한번만 적용하면 상수 $\gamma$와 변화된 $\bar t_j$-값을 얻을 수 있다.
\fi

\ifen
There are two atypical cases. First, if every school in $\mathcal{N}$ has $g_j > \bar H$, then there is no school that can be added to $\mathcal{I}$ in a feasible portfolio, and the optimal portfolio on this branch is $\mathcal{I}$ itself. In this case, we generate only one child by moving all the schools from $\mathcal{N}$ to $\mathcal{O}$. Second, if $\mathcal{N} = \O$, then the node has zero children, and as no further branching is possible, the node is called a \emph{leaf.}
\else
이례적인 경우 2가지 있다. 첫번째는, $\mathcal{N}$에 속한 모든 학교에 대해 $g_j > \bar H$이면 가능성을 유지하며 $\mathcal{I}$에 추가할 수 있는 학교가 없으므로 본 가지의 최적 포트폴리오는 단지 $\mathcal{I}$ 자체다. 이때 $\mathcal{N}$에 원소를 모두 $\mathcal{O}$로 이동시켜서 단일 새끼를 생성한다. 두번째는, $\mathcal{N} = \O$인 마디는 새끼가 없다. 더 이상 분지할 수 없으므로 이 마디를 `잎 마디'(leaf)라고 한다.
\fi

\begin{example}
\ifen
Consider a market in which $t = (20, 40, 60, 80, 100)$, $f = (0.5, 0.5, 0.5, 0.5, 0.5)$, $g = (3, 2, 3, 2, 3)$, and $H = 8$, and the node $n =  (\mathcal{I}, \mathcal{O}, \mathcal{N}) = (\{2, 5\}, \{1\}, \{3, 4\})$. Let us compute the two subproblems associated with $n$ and identify its children. To compute the subproblems, we first simply disregard $c_1$. Next, to eliminate $c_2$, we apply \eqref{howtotransformfj} to $t$ to obtain
$\{\bar{\bar t}_3, \bar{\bar t}_4, \bar{\bar t}_5\} = \{ (1 - f_2) t_3, (1 - f_2) t_4, (1 -f_2) t_5\} = \{30, 40, 50 \}$ and $\bar{\bar \gamma} = f_2 t_2 = 20$. We eliminate $c_5$ by again applying \eqref{howtotransformfj} to $\bar{ \bar t}$ to obtain $\{\bar t_3, \bar t_4\} =  \{\bar{\bar t}_3 - f_5 \bar{\bar t}_5, \bar{\bar t}_4-  f_5 \bar{\bar t}_5\}= \{5, 15\}$ and $\gamma = \bar{\bar \gamma} + f_5 \bar{\bar t}_5 = 35$. Finally, $\bar H = H - g_2 - g_5 = 3$. Now problems \eqref{nodenlpsubproblem} and \eqref{nodelprelaxation} are easily obtained by substitution.
\else
 $t = (20, 40, 60, 80, 100)$, $f = (0.5, 0.5, 0.5, 0.5, 0.5)$, $g = (3, 2, 3, 2, 3)$, 그리고 $H = 8$인 시장과 마디 $n =  (\mathcal{I}, \mathcal{O}, \mathcal{N}) = (\{2, 5\}, \{1\}, \{3, 4\})$이 주어질 때 $n$에 대응하는 부문제와 새끼 마디를 구하자. 부문제를 계산하기 위해 먼저 $c_1$을 단순히 무시한다.  $c_2$를 소거하기 위해 $t$에 \eqref{howtotransformfj}에 적용해서 
$\{\bar{\bar t}_3, \bar{\bar t}_4, \bar{\bar t}_5\} = \{ (1 - f_2) t_3, (1 - f_2) t_4, (1 -f_2) t_5\} = \{30, 40, 50 \}$과 $\bar{\bar \gamma} = f_2 t_2 = 20$을 얻는다. $c_5$를 소거하기 위해 $\bar{\bar t}$에 \eqref{howtotransformfj}에 다시 적용해서 $\{\bar t_3, \bar t_4\} =  \{\bar{\bar t}_3 - f_5 \bar{\bar t}_5, \bar{\bar t}_4-  f_5 \bar{\bar t}_5\}= \{5, 15\}$와 $\gamma = \bar{\bar \gamma} + f_5 \bar{\bar t}_5 = 35$를 얻는다. 마지막으로, $\bar H = H - g_2 - g_5 = 3$이다. 이제 \eqref{nodenlpsubproblem}과(와) \eqref{nodelprelaxation}인 부문제를 쉽게 구할 수 있다.
\fi

\ifen
Since at least one of the schools in $\mathcal{N}$ has $g_j \leq \bar H$, $n$ has two children. Applying the node-generation rule, $c_4$ has the highest $f_j \bar t_j / g_j$-ratio, so the children are $n_1 = (\{2, 4, 5\}, \{1\}, \{3\})$ and $n_2 = (\{2, 5\}, \{1, 4\}, \{3\})$.
\else
$\mathcal{N}$에 속한 학교 중에 $g_j \leq \bar H$인 학교가 있으므로 $n$은 새끼 마디 2개 있다. $f_j \bar t_j / g_j$-비율이 가장 높은 학교는 $c_4$이므로 새끼 마디를 생성하는 법칙을 적용하면 $n_1 = (\{2, 4, 5\}, \{1\}, \{3\})$과 $n_2 = (\{2, 5\}, \{1, 4\}, \{3\})$ 같은 새끼를 얻는다.
\fi
\end{example}

\ifen
To implement the branch-and-bound algorithm, we represent the set of candidate nodes---namely, nonleaf nodes whose children have not yet been generated---by $\mathfrak{T}$. Each time a node $n= (\mathcal{I}, \mathcal{O}, \mathcal{N})$ is generated, we record the values $v_{\mathcal{I}}[n] = v(\mathcal{I})$ and $v^*_{\mathrm{LP}}[n]$, the optimal objective value of the LP relaxation \eqref{nodelprelaxation}. Because $\mathcal{I}$ is a feasible portfolio, $v_{\mathcal{I}}[n]$ is a lower bound on the optimal objective value. Moreover, by the argument given in the proof of Theorem \ref{nestedapplication}, the objective function of  \eqref{nodenlpsubproblem} is identical to the function $v(\mathcal{I} \cup \mathcal{X})$. This means that $v_{\mathrm{LP}}^*[n]$  is an upper bound on the valuation of any portfolio that contains $\mathcal{I}$ as a subset and does not include any school in $\mathcal{O}$, and hence on the valuation of any portfolio on this branch. Therefore, if upon generating a new node $n_2$, we discover that its objective value $v_{\mathcal{I}}[n_2]$ is greater than $v_{\mathrm{LP}}^*[n_1]$ for some other node $n_1$, then we can disregard $n_1$ and all its descendants. 
\else
분지한계법을 실행하기 위해 후보 마디, 즉 잎이 아니면서 새끼를 아직 생성하지 않은 마디의 집합을  $\mathfrak{T}$라고 부르자. 마디 $n= (\mathcal{I}, \mathcal{O}, \mathcal{N})$를 생성할 때마다, $v_{\mathcal{I}}[n] = v(\mathcal{I})$과 선형 완화 문제 \eqref{nodelprelaxation}의 최대값 $v^*_{\mathrm{LP}}[n]$를 기록한다. $\mathcal{I}$는 예산에 가능한 포트폴리오이므로 $v_{\mathcal{I}}[n]$는 원래 목적함수 최대값의 하한이 된다. 또한 정리 \ref{nestedapplication}의 증명 과정에서 보였듯, \eqref{nodenlpsubproblem}의 목적함수는 함수 $v(\mathcal{I} \cup \mathcal{X})$과 동치다. 이는 $v_{\mathrm{LP}}^*[n]$는 $\mathcal{I}$를 부분집합으로 포함하며 $\mathcal{O}$에 속한 학교를 포함하지 않은, 즉 이 가지에 있는 모든 포트폴리오의 가치에 대한 상한임을 의미한다. 따라서 새로운 마디 $n_2$를 생성했을 때, 만약 그의 목적함수값 $v_{\mathcal{I}}[n_2]$가 어떤 다른 마디 $n_1$에 대응하는 $v_{\mathrm{LP}}^*[n_1]$보다 크다면, $n_1$과 그의 모든 후손을 무시할 수 있다.
\fi

\ifen
The algorithm is initialized by populating $\mathfrak{T}$ with the root node $n_0 = (\O, \O, \mathcal{C})$. At each iteration, it selects the node $n \in \mathfrak{T}$ having the highest $v_{\mathrm{LP}}^*[n]$-value, generates its children, and removes $n$ from the candidate set. Next, the children $n'$ of $n$ are inspected and added to the tree. If one of the children yields a new optimal solution, then we mark it as the best candidate and fathom any nodes $n''$ for which  $v_{\mathcal{I}}[n'] >  v_{\mathrm{LP}}^*[n'']$. When no nodes remain in the candidate set, the algorithm has explored every branch, so it returns the best candidate and terminates.
\else
$\mathfrak{T}$에 뿌리 마디 $n_0 = (\O, \O, \mathcal{C})$를 넣어서 알고리즘을 초기화한다. 각 반복단계에서 $v_{\mathrm{LP}}^*[n]$-값이 가장 높은 마디 $n \in \mathfrak{T}$을 선택한다. $n$의 새끼를 생성하고 후보 집합에서 제거한다. 그다음에 $n$의 각 새끼 마디 $n'$을 검증하고 나무에 추가한다. 새끼 마디 중에 새로운 최적해를 발견하면 이를 가장 좋은 후보로 표하고  $v_{\mathcal{I}}[n'] >  v_{\mathrm{LP}}^*[n'']$인 마디 $n''$을 후보 집합에서 제거한다. 후보 집합이 공집합이 되면 알고리즘이 모든 가지를 탐색했으므로 가장 좋은 후보를 출력하고 종료한다.
\fi


\ifen {
\begin{algorithm}[h] 
%\DontPrintSemicolon
\caption{Branch and bound for Ellis's problem.} \label{ellisbnb}
\KwData{Utility values $t \in(0, \infty)^m$, admissions probabilities $f \in (0, 1]^m$, application costs $g \in (0, \infty)^m$, budget $H \in (0, \infty)$.}
Root node $n_0 \gets (\O, \O, \mathcal{C})$\;
Current lower bound $L \gets 0$ and best solution $\mathcal{X} \gets \O$\;
Candidate set $\mathfrak{T} \gets \{ n_0\}$\;
\While{not finished}{
	\lIf{$\mathfrak{T} = \O$}{\Return{$\mathcal{X}, L$}}
	\Else{
		$n \gets \argmax\{ v_{\mathrm{LP}}^*[n] : n \in \mathfrak{T}\}$\;
		Remove $n$ from $\mathfrak{T}$\;
%		Generate children of $n$\;
		\For{each child $n'$ of $n$}{
			\If{$L < v_{\mathcal{I}}[n']$}{
				$L \gets v_{\mathcal{I}}[n']$\;
				Update $\mathcal{X}$ to the $\mathcal{I}$-set associated with $n'$\;
			}
			\lIf{$v_{\mathrm{LP}}^*[n] > L$ and $n'$ is not a leaf}{add $n'$ to $\mathfrak{T}$}
		}
		\For{$n'' \in \mathfrak{T}$} {
			\lIf{$L >  v_{\mathrm{LP}}^*[n'']$}{remove $n''$ from $\mathfrak{T}$}
		}
	}
}
\end{algorithm}
} \else {
\begin{algorithm}[h] 
%\DontPrintSemicolon
\caption{엘리스의 문제를 위한 분지한계법.} \label{ellisbnb}
\KwData{효용 모수 $t \in(0, \infty)^m$, 합격 확률 $f \in (0, 1]^m$, 지원 비용 $g \in (0, \infty)^m$, 예산 $H \in (0, \infty)$.}
뿌리 마디 $n_0 \gets (\O, \O, \mathcal{C})$\;
현재 하한 $L \gets 0$ 및 최적해 $\mathcal{X} \gets \O$\;
후보 집합 $\mathfrak{T} \gets \{ n_0\}$\;
\While{종료되지 않음}{
	\lIf{$\mathfrak{T} = \O$}{\Return{$\mathcal{X}, L$}}
	\Else{
		$n \gets \argmax\{ v_{\mathrm{LP}}^*[n] : n \in \mathfrak{T}\}$\;
		$\mathfrak{T}$에서 $n$을 제거한다\;
%		Generate children of $n$\;
		\For{$n$의 각 새끼 마디 $n'$}{
			\If{$L < v_{\mathcal{I}}[n']$}{
				$L \gets v_{\mathcal{I}}[n']$\;
				$\mathcal{X}$을 $n'$에 대응하는 $\mathcal{I}$-집합으로 수정한다\;
			}
			\lIf{$v_{\mathrm{LP}}^*[n] > L$이고 $n'$이 잎 마디 아님}{$\mathfrak{T}$에 $n'$을 추가한다}
		}
		\For{$n'' \in \mathfrak{T}$} {
			\lIf{$L >  v_{\mathrm{LP}}^*[n'']$}{$\mathfrak{T}$에서 $n''$을 제거한다}
		}
	}
}
\end{algorithm}
} \fi

\begin{theorem}[\ifen Validity of Algorithm \ref{ellisbnb}\else 알고리즘 \ref{ellisbnb}의 타당성\fi]
\ifen Algorithm \ref{ellisbnb} produces an optimal application portfolio for Ellis's problem.
\else 알고리즘 \ref{ellisbnb}은(는) 엘리스 문제의 최적 지원 포트폴리오를 출력한다. \fi
\end{theorem}

\begin{proof}
\ifen
Because an optimal solution exists among the leaves of the tree, the discussion above implies that as long as the algorithm terminates, it returns an optimal solution.

To show that the algorithm does not cycle, it suffices to show that no node is generated twice. Suppose not: that two distinct nodes $n_1$ and $n_2$ share the same partition $(\mathcal{I}_{12}, \mathcal{O}_{12}, \mathcal{N}_{12})$. Trace each node's lineage up the tree and let $n$ denote the \emph{first} node at which the lineages meet. $n$ must have two children, or else its sole child is a common ancestor of $n_1$ and $n_2$, and one of these children, say $n_3$, must be an ancestor of $n_1$ while the other, say $n_4$, is an ancestor of $n_2$.  Write $n_3 = (\mathcal{I}_{3}, \mathcal{O}_{3}, \mathcal{N}_{3})$ and $n_4 = (\mathcal{I}_{4}, \mathcal{O}_{4}, \mathcal{N}_{4})$. By the node-generation rule, there is a school $j$ in $\mathcal{I}_3 \cap \mathcal{O}_4$, and the $\mathcal{I}$-set (respectively, $\mathcal{O}$-set) for any descendant of $\mathcal{I}_3$ (respectively, $\mathcal{O}_4$) is a superset of  $\mathcal{I}_3$ (respectively, $\mathcal{O}_4$). Therefore, $j \in \mathcal{I}_{12} \cap \mathcal{O}_{12}$, meaning that $(\mathcal{I}_{12}, \mathcal{O}_{12}, \mathcal{N}_{12})$ is not a partition of $\mathcal{C}$, a contradiction. 
\else
나무의 잎 마디 중 최적해가 반드시 존재하므로 위의 논의에 따라 알고리즘이 종료한다면 최적해를 출력하는 것을 알 수 있다.

알고리즘에서 회로가 생기지 않음을 보이기 위해 어떤 한 마디가 두번 생성되지 않는 것을 증명하면 충분하다. 모순을 보이기 위해 같은 분할 $(\mathcal{I}_{12}, \mathcal{O}_{12}, \mathcal{N}_{12})$를 가지는 상이한 마디 $n_1$과 $n_2$가 생성된다고 하자. 나무에 올라가면서 두 마디의 가계가 서로 만나는 첫 마디를 $n$이라고 하자. $n$은 새끼 마디 하나만 가지면 그 자체가  $n_1$과 $n_2$의 공통 선조가 되며 이는 모순이므로 $n$ 새끼의 개수가 2임을 알 수 있다. 또한 그 중 하나는 $n_1$의 선조며 다른 하나는 $n_2$의 선조다. 각각 $n_3 = (\mathcal{I}_{3}, \mathcal{O}_{3}, \mathcal{N}_{3})$ 그리고 $n_4 = (\mathcal{I}_{4}, \mathcal{O}_{4}, \mathcal{N}_{4})$라고 하자. 마디 생성 규칙에 따라 $\mathcal{I}_3 \cap \mathcal{O}_4$에 속한 학교 $j$가 존재하며,  $\mathcal{I}_3$ ($\mathcal{O}_4$)의 모든 후손 마디의 $\mathcal{I}$-집합 ($\mathcal{O}$-집합)은  $\mathcal{I}_3$ ($\mathcal{O}_4$)의 확대 집합이다. 따라서 $j \in \mathcal{I}_{12} \cap \mathcal{O}_{12}$가 되며 이는 $(\mathcal{I}_{12}, \mathcal{O}_{12}, \mathcal{N}_{12})$가 $\mathcal{C}$의 분할이 아님을 의미한다. 모순. 
\fi
\end{proof}

\ifen
The branch-and-bound algorithm is an interesting benchmark, but as a kind of enumeration algorithm, its computation time grows rapidly in the problem size, and unlike the approximation scheme we propose later on, there is no guaranteed bound on the approximation error after a fixed number of iterations. Moreover, when there are many schools in $\mathcal{N}$, the LP upper bound may be much higher than $v_{\mathcal{I}}[n']$. This means that significant fathoming operations do not occur until the algorithm has explored deep into the tree, at which point the bulk of the computational effort has already been exhausted. In our numerical experiments, Algorithm \ref{ellisbnb} was ineffective on instances larger than about $m=35$ schools, and therefore it does not represent a significant improvement over na\"ive enumeration. 
\else
분지한계법은 기술적으로 유리한 기준점이지만, 일종의 열거 해법이므로 계산 시간이 문제 크기와 지수적으로 늘어난다. 그리고 뒤에서 제안하는 근사 해법과 달리, 주어진 반복한계의 개수에 대한 정확성 보장이 없다. 또한 $\mathcal{N}$에 학교가 많을 때, 선형 완화 문제 상한은 $v_{\mathcal{I}}[n']$보다 매우 높을 수도 있다. 이는 해법이 나무에 어느 정도 깊게 파고들어야 마디를 제외시킬 수 있음을 의미하며, 그때 계산 노력의 대부분은 이미 쏟은 것이다. 수리 실험에서, 알고리즘 \ref{ellisbnb}은(는) 약 $m=35$개의 학교를 넘는 인스턴스에 대해 비효율적이었으며 이는 단순한 열거법에 비해 큰 개선이 아니다.
\fi





\ifen \subsection{Pseudopolynomial-time dynamic program} \else\subsection{의사 다항 시간 동적 계획} \fi
\ifen
In this subsection, we assume, with a small loss of generality, that $g_j \in \mathbb{N}$ for $j = 1\dots m$ and $H \in\mathbb{N}$, and provide an algorithmic solution to Ellis's problem that runs in $O(Hm + m\log m)$-time. The algorithm resembles a familiar dynamic programming algorithm for the binary knapsack problem (Dantzig 1957; \emph{Wikipedia}, s.v. ``Knapsack problem''). Because we cannot assume that $H \leq m$ (as was the case in Alma's problem), this represents a pseudopolynomial-time solution (Garey and Johnson 1979, \S\,4.2). However, it is quite effective for typical college-application instances in which the application costs are small integers.
\else
본 절에서 일반성을 약간 제한해서 $g_j \in \mathbb{N}$ for $j = 1\dots m$과 $H \in\mathbb{N}$임을 가정한다. 이때 엘리스의 문제를 위한 $O(Hm + m\log m)$-시간 해법을 제시한다. 해법은 이진 배낭 문제를 위한 익숙한 동적 계획 해법과 비슷하다 (Dantzig 1957; \emph{Wikipedia}, s.v. ``Knapsack problem''). 알마의 문제와 달리, 여기에서 $H \leq m$임을 가정할 수 없으므로 이는 의사 다항 시간 해법이라고 한다 (Garey and Johnson 1979, \S\,4.2). 그러나 지원 비용이 작은 정수가 되는 전형적인 대학 지원 문제 인스턴스에 대해 매우 효율적인 해법이다.
\fi

\ifen 
For $j = 0 \dots m$ and $h = 0 \dots H$, let $\mathcal{X}[j, h]$ denote the optimal portfolio using only the schools $\{ 1, \dots, j\}$ and costing no more than $h$, and let $V[j,h] = v(\mathcal{X}[j, h])$.  It is clear that if $j=0$ or $h=0$, then $\mathcal{X}[j, h] = \O$ and $V[j, h] = 0$.  For convenience, we also define $V[j, h] = -\infty$ for all $h < 0$.
\else
$j = 0 \dots m$와 $h = 0 \dots H$에 대해, $\{ 1, \dots, j\}$에 속한 학교만 사용하면서 지원 지출액이 $h$을 넘지 않는 최적 포트폴리오를 $\mathcal{X}[j, h]$라고 하자. 또한  $V[j,h] = v(\mathcal{X}[j, h])$이다. $j=0$ 혹은 $h=0$이면 $\mathcal{X}[j, h] = \O$이고 $V[j, h] = 0$이 되는 것은 분명하다. 편의상 $h < 0$이면 $V[j, h] = -\infty$이라고 정의하자.
\fi

\ifen
For the remaining indices, $\mathcal{X}[j, h]$ either contains $j$ or not. If it does not contain $j$, then $\mathcal{X}[j, h] = \mathcal{X}[j-1, h]$. On the other hand, if  $\mathcal{X}[j, h]$ contains $j$, then its valuation is $(1 - f_j) v(\mathcal{X}[j, h]\setminus \{j\}) + f_j t_j$. This requires that $\mathcal{X}[j, h]\setminus \{j\}$ make optimal use of the remaining budget over the remaining schools; that is, $\mathcal{X}[j, h] = \mathcal{X}[j-1, h - g_j] \cup\{j\}$. From these observations, we obtain the following Bellman equation for $ j = 1\dots m$ and $h = 1\dots H$:
\else
남은 지표에 대해, $\mathcal{X}[j, h]$는 $j$를 포함하거나 포함하지 않는다. $j$를 포함하지 않는다면 $\mathcal{X}[j, h] = \mathcal{X}[j-1, h]$이다. $\mathcal{X}[j, h]$가 $j$를 포함한다면, 그의 가치는  $(1 - f_j) v(\mathcal{X}[j, h]\setminus \{j\}) + f_j t_j$이다. 따라서 $\mathcal{X}[j, h]\setminus \{j\}$는 남은 예산과 남은 학교에 대한 최적 포트폴리오다. 즉,  $\mathcal{X}[j, h] = \mathcal{X}[j-1, h - g_j] \cup\{j\}$이다. 이 관찰에 따라 $ j = 1\dots m$와 $h = 1\dots H$에 대해 다음 같은 Bellman 식을 얻는다.
\fi
\begin{align}
V[j, h] = \max\bigl\{ V[j-1, h], (1 - f_j) V[j-1, h-g_j] + f_j t_j \bigr\}
\end{align}
\ifen 
with the convention that $ -\infty \cdot 0 = -\infty$. The corresponding optimal portfolios are computed by observing that $\mathcal{X}[j, h]$ contains $j$ if and only if $V[j, h]> V[j-1, h]$. The optimal solution is given by $\mathcal{X}[m, H]$. The algorithm below performs these computations and outputs the optimal portfolio $\mathcal{X}$. 
\else
단, $ -\infty \cdot 0 = -\infty$으로 처리한다. 그러면 $\mathcal{X}[j, h]$가  $j$를 포함할 필수충분 조건이 $V[j, h]> V[j-1, h]$임을 관찰하면 대응되는 최적 포트폴리오를 계산할 수 있으며 전역 최적해는 $\mathcal{X}[m, H]$이다. 아래 알고리즘은 이 계산을 수행하고 최적 포트폴리오 $\mathcal{X}$를 출력한다.
\fi



\ifen {
\begin{algorithm}[h] 
%\DontPrintSemicolon
\caption{Dynamic program for Ellis's problem with integral application costs.} \label{ellisDP1}
\KwData{Utility values $t \in(0, \infty)^m$, admissions probabilities $f \in (0, 1]^m$, application costs $g \in \mathbb{N}^m$, budget $H \in\mathbb{N}$.}
Index schools in ascending order by $t$\;
%\SetKwProg{Fn}{function}{ do}{end}
%\Fn{$V(j, h)$}{
%	\lIf{$h < g_j$}{\Return{$-\infty$}}
%	\lElseIf{$j = 0$ or $h=0$}{\Return{$0$}}
%	\lElse{\Return{$\max\bigl\{ V(j-1, h), (1 - f_j) V(j-1, h-g_j) + f_j t_j \bigr\}$}}
%}
Fill a lookup table with the values of $V[j, h]$\; \label{Vcreatedlookuptable}
$h \gets H$\;
$\mathcal{X} \gets \O$\;
\For{$j = m, m-1, \dots, 1$}{
	\If{$V[j-1, h] < V[j, h]$}{
		$\mathcal{X} \gets \mathcal{X}\cup\{j\}$\; 
		$h \gets h - g_j$\;
	}
}
\Return{$\mathcal{X}$}
\end{algorithm}
} \else {
\begin{algorithm}[h] 
%\DontPrintSemicolon
\caption{정수 지원 비용의 엘리스 문제를 위한 동적 계획 해법.} \label{ellisDP1}
\KwData{효용 모수 $t \in(0, \infty)^m$, 합격 확률 $f \in (0, 1]^m$, 지원 비용 $g \in \mathbb{N}^m$, 예산 $H \in\mathbb{N}$.}
$t$의 순서대로 학교를 배열한다\;
%\SetKwProg{Fn}{function}{ do}{end}
%\Fn{$V(j, h)$}{
%	\lIf{$h < g_j$}{\Return{$-\infty$}}
%	\lElseIf{$j = 0$ or $h=0$}{\Return{$0$}}
%	\lElse{\Return{$\max\bigl\{ V(j-1, h), (1 - f_j) V(j-1, h-g_j) + f_j t_j \bigr\}$}}
%}
$V[j, h]$의 값으로 표를 채운다\; \label{Vcreatedlookuptable}
$h \gets H$\;
$\mathcal{X} \gets \O$\;
\For{$j = m, m-1, \dots, 1$}{
	\If{$V[j-1, h] < V[j, h]$}{
		$\mathcal{X} \gets \mathcal{X}\cup\{j\}$\; 
		$h \gets h - g_j$\;
	}
}
\Return{$\mathcal{X}$}
\end{algorithm}
}\fi

\begin{theorem}[\ifen Validity of Algorithm \ref{ellisDP1}\else 알고리즘 \ref{ellisDP1}의 타당성\fi]
\ifen 
Algorithm \ref{ellisDP1} produces an optimal application portfolio for Ellis's problem in $O(H m + m \log m)$-time.
\else
알고리즘 \ref{ellisDP1}은(는) $O(H m + m \log m)$-시간 안의 엘리스 문제의 최적 포트폴리오를 출력한다.
\fi
\end{theorem}

\begin{proof}
\ifen
Optimality follows from the foregoing discussion. Sorting $t$ is $O(m \log m)$. The bottleneck step is the creation of the lookup table for $V[j, h]$ in line \ref{Vcreatedlookuptable}. Each entry is generated in unit time, and the size of the table is $O(Hm)$. 
\else
위 논의에 따라 최적성이 성립한다. $t$를 배열하는 시간은 $O(m \log m)$이다. 목병 단계는 \ref{Vcreatedlookuptable}줄에서 $V[j, h]$의 표를 만드는 것이다. 각 원소를 단위 시간 안에 생성할 수 있으며 표의 크기가 $O(Hm)$이다.
\fi
\end{proof}







\ifen \subsection{Fully polynomial-time approximation scheme}\else \subsection{완전 다항 시간 근사 해법}\fi \label{fptashead}
\ifen 
As with the knapsack problem, Ellis's problem admits a complementary dynamic program that iterates on the value of the cheapest portfolio instead of on the cost of the most valuable portfolio. We will use this algorithm as the basis for a fully polynomial-time approximation scheme (FPTAS) for Ellis's problem that uses $O(m^3 / \varepsilon)$-time and -space. Here we assume, with a small loss of generality, that each $t_j$ is a natural number.
%Now, we modify Algorithm \ref{ellisDP2} into a fully polynomial-time approximation scheme for Ellis's problem.
\else
엘리스의 문제는 배낭 문제와 같이, 가치가  가장 높은 포트폴리오의 비용 대신 비용이 가장 낮은 포트폴리오의 가치를 탐색하는 보완적인 동적 계획이 존재한다. 이를 기반으로  $O(m^3 / \varepsilon)$-시간과 -공간을 사용하는 엘리스 문제의 완전 다항 시간 근사 해법(fully polynomial-time approximation scheme, FPTAS)을 도출할 수 있다. 여기서 일반성을 약간 제안해서 각 $t_j$가 자연수임을 가정한다.
\fi


\ifen 
We will represent approximate portfolio valuations using a fixed-point decimal with a precision of $P$, where $P$ is the number of digits to retain after the decimal point. Let $r[x] =  10^{-P}\lfloor 10^P x \rfloor$ denote the value of $x$ rounded down to its nearest fixed-point representation. Since $\bar U = \sum_{j\in \mathcal{C}} f_j t_j$ is an upper bound on the valuation of any portfolio, and since we will ensure that each fixed-point approximation is an underestimate of the portfolio's true valuation, the set $\mathcal{V}$ of possible valuations possible in the fixed-point framework is finite:
\else
포트폴리오의 근사적 가치를 정확도 $P$로 구성된 고정소수점 십진수(fixed-point decimal)로 나타내자. 다, $P$는 소수점 뒤에 등장하는 숫자의 수다. 이때 $x$를 가장 가까운 고정소수점 십진수로 내림한 것을 $r[x] =  10^{-P}\lfloor 10^P x \rfloor$라고 하자. 임의의 포트폴리오의 가치가 $\bar U = \sum_{j\in \mathcal{C}} f_j t_j$를 넘을 수 없으며, 모든 포트폴리오 가치의 고정소수점 십진수 근사가 실제값보다 작게 나타내도록 한다. 따라서 고정소수점 환경에서 발생할 수 있는 포트폴리오 가치로 이루어진 집합 $\mathcal{V}$는 유한 집합이다.
\fi
\begin{equation}
\mathcal{V} = \Bigl\{0, 1\times 10^{-P}, 2\times 10^{-P}, \dots, r\bigl[\bar U- 1\times 10^{-P}\bigr], r\bigl[\bar U\bigr]\Bigr\}
\end{equation}
\ifen Then $|\mathcal{V} | = \bar U \times 10^P + 1$.
\else 그러면 $|\mathcal{V} | = \bar U \times 10^P + 1$이다.\fi

\ifen
For the remainder of this subsection, unless otherwise specified, the word \emph{valuation} refers to a portfolio’s valuation within the fixed-point framework, with the understanding that this is an approximation. We will account for the approximation error below when we prove the dynamic program’s validity. 
\else
본 항 나머지에서, 다른 언급이 없으면 포트폴리오의 ``가치''라고 하면 고정소수점 환경 안에서의 가치를 의미하며 이것이 근사값임을 유념한다. 나중에 동적 계획의 타당성을 증명할 때 근사 오차를 처리한다.
\fi

\ifen
For integers $0 \leq j \leq m$ and $v \in [-\infty, 0) \cup \mathcal{V}$, let $\mathcal{W}[j, v]$ denote the least expensive portfolio that uses only schools $\{ 1, \dots, j\}$ and has valuation at least $v$, if such a portfolio exists. Denote its cost by $G[j, v] = \sum_{j\in \mathcal{W}[j, v]} g_j$, where $G[j, v] = \infty$ if $\mathcal{W}[j, v]$ does not exist. It is clear that if $v \leq 0$, then $\mathcal{W}[j, v] = \O$ and $G[j, h] = 0$, and that if $j = 0$ and $v > 0$, then $G[j, h] = \infty$.  For the remaining indices (where $j, v > 0$), we claim that
\else
정수 $0 \leq j \leq m$ 그리고 $v \in [-\infty, 0) \cup \mathcal{V}$에 대해, $\{ 1, \dots, j\}$에 속한 학교만 사용하면 최소한 $v$의 가치를 가지는 포트폴리오가 존재한다면 그 중 가장 비용이 낮은 포트폴리오를  $\mathcal{W}[j, v]$라고 하자. 그의 비용을 $G[j, v] = \sum_{j\in \mathcal{W}[j, v]} g_j$라고 하자. 단, $\mathcal{W}[j, v]$가 존재하지 않으면 $G[j, v] = \infty$으로 처리한다. $v \leq 0$이면 $\mathcal{W}[j, v] = \O$이고 $G[j, h] = 0$이며, $j = 0$이고 $v > 0$이면 $G[j, h] = \infty$인 것이 분명하다. 남은 지표(즉 $j, v > 0$)는 다음을 만족한다.
\fi
\begin{align} \label{recursionrelationforcostmindp}
G[j, v] &=
\begin{cases}
\infty, \quad & t_j < v \\
\min\bigl\{G[j-1, v], g_j + G[j-1, v - \Delta_j(v)] \bigr\}, \quad & t_j \geq v 
%\begin{cases}
%\min\bigl\{G[j-1, v], g_j + G[j-1, v - \Delta] \bigr\}, \quad &f_j < 1 \\
%\min\bigl\{G[j-1, v], g_j \bigr\}, \quad &f_j = 1 \text{ and } f_j t_j \geq v\\
%G[j-1, v], \quad &f_j = 1 \text{ and } f_j t_j < v
\end{cases}\\
\text{where}\qquad
\Delta_j (v) &= 
\begin{cases}
r\left[\frac{f_j}{1 - f_j} (t_j - v)\right], \quad & f_j < 1\\
\infty, &f_j = 1\ifen.\fi
\end{cases} \label{deltajvdef}
\end{align}
\ifen
In the $t_j < v$ case, any feasible portfolio must be composed of schools with utility less than $v$, and therefore its valuation can not equal $v$, meaning that $\mathcal{W}[j, v]$ is undefined. In the $t_j \geq v$ case, the first argument to $\min\{\}$ says simply that omitting $j$ and choosing $\mathcal{W}[j-1, v]$ is a permissible choice for $\mathcal{W}[j, v]$. If, on the other hand, $j \in \mathcal{W}[j, v]$, then
\else
$t_j < v$인 경우, 가능한 포트폴리오는 효용이 $v$보다 작은 학교로 구성되므로 그의 가치는 $v$를 넘을 수가 없고 $\mathcal{W}[j, v]$가 정의되지 않는다. $t_j \geq v$인 경우, $\min\{\}$의 첫 입력값은 $j$를 제외하고 $\mathcal{W}[j-1, v]$로 지원하는 것이 가능한 선택임을 의미한다. 반면에 $j \in \mathcal{W}[j, v]$이라면 다음이 성립한다.
\fi
\begin{equation} \label{solvemeforvwjvminusj}
v(\mathcal{W}[j, v]) = (1 - f_j )v(\mathcal{W}[j, v]\setminus \{j\}) + f_j t_j\ifen.\fi\end{equation}
\ifen
Therefore, the subportfolio $\mathcal{W}[j, v]\setminus \{j\}$ must have a valuation of at least $v - \Delta$, where $\Delta$ satisfies $v = (1 - f_j )(v - \Delta) + f_j t_j $. When $f_j < 1$, the solution to this equation is $ \Delta = \frac{f_j}{1 - f_j} (t_j - v)$. By rounding this value down, we ensure that the true valuation of $\mathcal{W}[j, v]$ is \emph{at least} $v - \Delta$. When $t_j \geq v$ and $f_j = 1$, the singleton $\{j\}$ has $v(\{j\}) \geq v$, so
\else
이는 부분 포트폴리오 $\mathcal{W}[j, v]\setminus \{j\}$가 최소한 $v - \Delta$의 가치를 가져야 한다고 의미한다. 단,  $\Delta$는 $v = (1 - f_j )(v - \Delta) + f_j t_j $를 만족한다. $f_j < 1$일 때, 이 식의 해는 $ \Delta = \frac{f_j}{1 - f_j} (t_j - v)$이다. 이값을 내림함으로써 $\mathcal{W}[j, v]$가 `최소한' $v - \Delta$임을 보장한다. $t_j \geq v$이고 $f_j = 1$일 때, 단일 원소 집합 $\{j\}$에 대해 $v(\{j\}) \geq v$이므로
\fi
\begin{equation}G[j, v] = \min\bigl\{G[j-1, v], g_j \bigr\}.\end{equation}
\ifen
Defining $\Delta_j(v) = \infty$ in this case ensures that $g_j + G[j-1, v-\Delta_j(v)] = g_j+ G[j-1, v-\infty] = g_j $ as required.
\else
이때 $\Delta_j(v) = \infty$으로 정의하면 $g_j + G[j-1, v-\Delta_j(v)] = g_j+ G[j-1, v-\infty] = g_j $와 같은 적절한 값이 나온다.
\fi
%we have $t_j < v$, and since no portfolio can be more valueable than the largest $t_j$ value of its elements, we must have $G[j, v] =\infty$. Defining $\Delta$ as zero in this guess automatically chooses $G[j, v] = G[j-1, v] = \infty$ for the same reason.
%
%In the $f_j t_j \geq v$ case, the singleton $\{j\}$ is feasible for $j$ and $v$, so $\mathcal{W}[j, v]$ is simply the cheaper of $\{j\}$ and $.\mathcal{W}[j-1, v]$.

\ifen
Once $G[j, v]$ has been calculated at each index, the associated portfolio can be found by applying the observation that $\mathcal{W}[j, v]$ contains $j$ if and only if $G[j, v] < G[j-1, v]$. Then an approximate solution to Ellis's problem is obtained by computing the largest achievable objective value $\max\{ w: G[m, w] \leq H\}$ and corresponding portfolio.
\else
각 지표에 대해 $G[j, v]$를 계산한 다음에,  $\mathcal{W}[j, v]$가 $j$를 포함할 필수충분 조건인 $G[j, v] < G[j-1, v]$를 적용하면 해당 최적 포트폴리오를 구할 수 있다. 그러면 가능하면서 최대적인 목적함수값 $\max\{ w: G[m, w] \leq H\}$와 해당 포트폴리오를 계산하면 엘리스 문제의 근사해를 얻을 수 있다.
\fi


\ifen
\begin{algorithm}[h] 
%\DontPrintSemicolon
\caption{Fully polynomial-time approximation scheme for Ellis's problem.} \label{ellisDP3}
\KwData{Utility values $t \in \mathbb{N}^m$, admissions probabilities $f \in (0, 1]^m$, application costs $g \in (0, \infty)^m$, budget $H \in (0, \infty)^m$, tolerance $\varepsilon \in (0, 1)$.}
Index schools in ascending order by $t$\;
Set precision $P \gets \bigl\lceil\log_{10}\left(m^2 / \varepsilon \bar U\right)\bigr\rceil$\;
%\SetKwProg{Fn}{function}{ do}{end}
%\Fn{$G(j, v)$}{
%	\lIf{$v \leq 0$}{\Return{$0$}}
%	\lElseIf{$j=0$ or $t_j < v$}{\Return{$\infty$}}
%	\lElse {\Return{$\min\bigl\{ G(j-1, v), g_j + G\bigl(j-1, v -  \Delta_j(v)\bigr) \bigr\}$}}
%}
Fill a lookup table with the entries of $G[j, h]$\; \label{createdlookuptable}
$v\gets  \max\{ w \in \mathcal{V} : G[m, w] \leq H\}$\; \label{vrecordedhere}
$\mathcal{X} \gets \O$\;
\For{$j = m, m-1, \dots, 1$}{
	\If{$G[j, v]< \infty$ and $G[j, v] < G[j-1, v]$}{
		$\mathcal{X} \gets \mathcal{X}\cup\{j\}$\; 
		$v \gets v -  \Delta_j(v)$\;
	}
}
\Return{$\mathcal{X}$}
\end{algorithm}
\else
\begin{algorithm}[h] 
%\DontPrintSemicolon
\caption{엘리스의 문제를 위한 완전 다항 시간 근사 해법.} \label{ellisDP3}
\KwData{효용 모수 $t \in \mathbb{N}^m$, 합격 확률 $f \in (0, 1]^m$, 지원 비용 $g \in (0, \infty)^m$, 예산 $H \in (0, \infty)^m$, 허용치 $\varepsilon \in (0, 1)$.}
$t$의 순서대로 학교를 배열한다\;
정확도 $P \gets \bigl\lceil\log_{10}\left(m^2 / \varepsilon \bar U\right)\bigr\rceil$\;
%\SetKwProg{Fn}{function}{ do}{end}
%\Fn{$G(j, v)$}{
%	\lIf{$v \leq 0$}{\Return{$0$}}
%	\lElseIf{$j=0$ or $t_j < v$}{\Return{$\infty$}}
%	\lElse {\Return{$\min\bigl\{ G(j-1, v), g_j + G\bigl(j-1, v -  \Delta_j(v)\bigr) \bigr\}$}}
%}
$G[j, h]$의 값으로 표를 채운다\; \label{createdlookuptable}
$v\gets  \max\{ w \in \mathcal{V} : G[m, w] \leq H\}$\; \label{vrecordedhere}
$\mathcal{X} \gets \O$\;
\For{$j = m, m-1, \dots, 1$}{
	\If{$G[j, v]< \infty$이고 $G[j, v] < G[j-1, v]$}{
		$\mathcal{X} \gets \mathcal{X}\cup\{j\}$\; 
		$v \gets v -  \Delta_j(v)$\;
	}
}
\Return{$\mathcal{X}$}
\end{algorithm}
\fi

\begin{theorem}[\ifen Validity of Algorithm \ref{ellisDP3}\else 알고리즘 \ref{ellisDP3}의 타당성\fi]
\ifen
Algorithm \ref{ellisDP3} produces a $(1 - \varepsilon)$-optimal application portfolio for Ellis's problem in $O(m^3 /\varepsilon)$-time. % and $O(m^3/\varepsilon)$ space.
\else
알고리즘 \ref{ellisDP3}은(는) $O(m^3 /\varepsilon)$-시간 안에 엘리스의 문제를 위한 $(1 - \varepsilon)$-근사 최적 포트폴리오를 출력한다.
\fi
\end{theorem}

\begin{proof}
\ifen
(Optimality.) Let $\mathcal{W}$ denote the output of Algorithm \ref{ellisDP3} and $\mathcal{X}$ the true optimum. We know that $v(\mathcal{X}) \leq \bar U$, and because each singleton portfolio is feasible, $\mathcal{X}$ must be more valuable than the average singleton portfolio; that is, $v(\mathcal{X}) \geq \bar U / m$.
\else
(최적성.) 알고리즘 \ref{ellisDP3}의 출력이 $\mathcal{W}$이며 실제 최적해가 $\mathcal{X}$라고 하자. $v(\mathcal{X}) \leq \bar U$이고, 모든 단일 원소 포트폴리오가 가능해므로  $\mathcal{X}$는 평균적인 단일 원서 포트폴리오보다 가치 높을 수 밖에 없다. 즉,  $v(\mathcal{X}) \geq \bar U / m$이다.
\fi

\ifen
Because $\Delta_j(v)$ is rounded down in the recursion relation defined by \eqref{recursionrelationforcostmindp} and \eqref{deltajvdef}, if $j \in \mathcal{W}[j, v]$, then the true value of $(1 - f_j) v\bigl(\mathcal{W}[j-1, v- \Delta_j(v)]\bigr) + f_j t_j$ may exceed the fixed-point valuation $v$ of $\mathcal{W}[j, v]$, but not by more than $10^{-P}$. This error accumulates additively with each school added to $\mathcal{W}$, but the number of additions is at most $m$. Therefore, where $v'(\mathcal{W})$ denotes the fixed-point valuation of $\mathcal{W}$ recorded in line \ref{vrecordedhere} of the algorithm, 
$v(\mathcal{W}) - v'(\mathcal{W}) \leq m 10^{-P}$.
\else
\eqref{recursionrelationforcostmindp}과(와) \eqref{deltajvdef}(으)로 정의된 점화식에 따라 $\Delta_j(v)$를 내림하기 때문에, $j \in \mathcal{W}[j, v]$이면 $(1 - f_j) v\bigl(\mathcal{W}[j-1, v- \Delta_j(v)]\bigr) + f_j t_j$의 실제값은 $\mathcal{W}[j, v]$의 고정소수점값인 $v$보다 클 수 있는데 최대한 $10^{-P}$ 만큼의 차이가 발생하다. 또한 이 오차는 $\mathcal{W}$에 학교를 추가할 때마다 가산적으로 누적되는데 추가하는 학교의 개수는 최대한 $m$이다. 따라서 알고리즘의 \ref{vrecordedhere}줄에서 기록하는 $\mathcal{W}$의 값이 $v'(\mathcal{W})$일 때, $v(\mathcal{W}) - v'(\mathcal{W}) \leq m 10^{-P}$이 성립한다.
\fi

\ifen
We can define $v'(\mathcal{X})$ analogously as the fixed-point valuation of $\mathcal{X}$ when its elements are added in index order and its valuation is updated and rounded down to the nearest multiple of $10^{-P}$ at each addition in accordance with \eqref{solvemeforvwjvminusj}. By the same logic, 
$v(\mathcal{X}) - v'(\mathcal{X}) \leq m 10^{-P}$. The optimality of $\mathcal{W}$ in the fixed-point environment implies that $v'(\mathcal{W}) \geq v'(\mathcal{X})$. 
\else
$\mathcal{X}$의 원소를 지표 순서대로 추가했을 때, 각 학교를 추가하면 \eqref{solvemeforvwjvminusj}에 따라 가치를 수정하고 가장 가까운 $10^{-P}$의 곱으로 내림한 값으로 $v'(\mathcal{X})$를 $v'(\mathcal{W})$와 유사하게 정의할 수 있다. 위와 같은 논리에 따라 $v(\mathcal{X}) - v'(\mathcal{X}) \leq m 10^{-P}$이다. 또한 $\mathcal{W}$가 고정소수점 환경에서 최적이므로 $v'(\mathcal{W}) \geq v'(\mathcal{X})$임을 알 수 있다.
\fi

\ifen
Applying these observations, we have
\else
위 관찰을 적용하면 다음 부등식을 도출할 수 있다.
\fi
%the fact that $\bar U / m \leq v(\mathcal{X} \leq \bar U$, we have
\begin{equation}
\begin{split}
v(\mathcal{W}) &\geq v'(\mathcal{W}) \geq v'(\mathcal{X})
\geq v(\mathcal{X}) - m 10^{-P}
%\\&
\geq \left(1 - \frac{m^2 10^{-P}}{\bar U}\right) v(\mathcal{X})
\geq \left(1 - \varepsilon\right) v(\mathcal{X})
\end{split}
\end{equation}
\ifen
which establishes the approximation bound. 
\else
이는 정리에서 말한 근사 계수다.
\fi

\ifen
(Computation time.) The bottleneck step is the creation of the lookup table in line \ref{createdlookuptable}, whose size is $m \times |\mathcal{V}|$. Since
\else
(계산 시간.) \ref{createdlookuptable}줄에서 표를 채우는 것이 목병 단계이며 표의 크기는 $m \times |\mathcal{V}|$이다. 그러면
\fi
\begin{equation}
|\mathcal{V}| = \bar U \times 10^{P} + 1 = \bar U \times 10^ { \bigl\lceil\log_{10}\left(m ^2/ \varepsilon \bar U\right)\bigr\rceil} + 1
\leq\frac{m^2}{\varepsilon} \times \text{\ifen const.\else 상수\fi}
\end{equation}
\ifen
is $O(m^2/ \varepsilon)$, the time complexity is as promised.
\else
는 $O(m^2/ \varepsilon)$이므로 시간 복잡성을 정리와 같다.
\fi%To prevent redundant recursive calls to $G(j, v)$, we need to record its values in a dictionary as they are computed; the space required by the dictionary is $O(|\mathcal{V}| m) = O(m^3 / \varepsilon)$.
\end{proof}

\ifen
Since its time complexity is polynomial in $m$ and $1 / \varepsilon$, Algorithm \ref{ellisDP3} is an FPTAS for Ellis's problem (Vazirani 2001). 

Algorithms \ref{ellisDP1} and \ref{ellisDP3} can be written using recursive functions instead of lookup tables. However, since each function references itself \emph{twice,} the function values at each index must be recorded in a lookup table or otherwise memoized to prevent an exponential number of calls from forming on the stack.
\else
계산 시간이 $m$과 $1 / \varepsilon$의 다항식으로 제한되므로  알고리즘 \ref{ellisDP3}은(는) 엘리스의 문제를 위한 FPTAS다 (Vazirani 2001). 

알고리즘 \ref{ellisDP1}과(와) 알고리즘 \ref{ellisDP3}을(를) 표 대신 재귀 함수 기반으로 구성할 수 있다. 그러나 각 재귀 함수가 스스로를 `두번' 호출하므로 지수적으로 늘어나는 호출 수를 방화하기 위해 각 지표에 대응하는 함수값을 표에 저장하거나 다른 식으로 기록해야 한다.
\fi


%\pagebreak
\ifen \section{Numerical experiments} \else \section{계산 실험}\fi\label{numericalexperiments}
\ifen
In this section, we present the results of numerical experiments designed to test the practical efficacy of the algorithms derived above. 
\else
본 절에서 위에서 도출한 알고리즘의 현실성을 탐구하고자 계산 실험의 결과를 제시한다.
\fi

\ifen \subsection{Implementation notes} \else \subsection{알고리즘의 실행}\fi
\ifen
We chose to implement our algorithms in the Julia language (v1.8.0b1) because its system of parametric data types allows the compiler to optimize for differential cases such as when the $t_j$-values are integers or floating-point numbers. Julia also offers convenient macros for parallel computing, which enabled us to solve more and larger problems in the benchmark (Bezanson et al. 2017). We made extensive use of the DataStructures.jl package (v0.18.11, \url{github.com/JuliaCollections}). The code is available at \url{https://github.com/maxkapur/OptimalApplication}.
\else
모든 알고리즘을 쥴리아 (Julia, v1.8.0b1) 언어로 실행했다. 쥴리아는 $t_j$-값이 정수 또는 부동소수점 수와 같은 특수한 경우에 대해 컴파일러가 자동적으로 최적화하는 모수적 자료형(parametric data type) 기능이 있어서 유용한 선택이었다. 또한 병렬 연산을 쉽게 관리할 수 있는 매크로를 제공하므로 계산 실험의 규모를 증가할 수 있었다 (Bezanson 외 2017). DataStructures.jl 패키지(v0.18.11, \url{github.com/JuliaCollections})도 활용했다. 실험 코드는  \url{https://github.com/maxkapur/OptimalApplication}에서 공유한다.
\fi

\ifen
The dynamic programs, namely Algorithms \ref{ellisDP1} and \ref{ellisDP3}, were implemented using recursive functions and dictionary memoization rather than a full lookup table. Our implementation of Algorithm \ref{ellisDP3} also differed from that described in Subsection \ref{fptashead} in that we represented portfolio valuations in \emph{binary} rather than decimal, with the definitions of $P$ and $\mathcal{V}$ modified accordingly, and instead of fixed-point numbers, we worked in integers by multiplying each $t_j$-value by $2^P$. These modifications yielded a substantial performance improvement without changing the fundamental algorithm design or complexity analysis.
\else
동적 계획 해법인 \ref{ellisDP1}과(와) 알고리즘 \ref{ellisDP3}을(를) 표 대신 사전 기록 및 재귀 함수로 실행했다. 알고리즘 \ref{ellisDP3}은(는) \ref{fptashead}항에서 설명한 것과 달리, 포트폴리오의 가치를 십진수 대신 `이진수'로 나타냈으며 $P$와  $\mathcal{V}$의 정의를 적절히 수정했다. 그리고 고정소수점 대신 $t_j$-값을 $2^P$으로 곱해서 정수로 구성했다. 이런 변경은 기본 알고리즘 설계와 계산 시간 분석은 변하지 않는데 성능은 많이 개선한다.
\fi


\ifen \subsection{Experimental procedure} \else \subsection{실험 방법}\fi
\def\nmarkets{50}
\ifen
The experimental procedure was as follows. First, to generate synthetic markets, we drew the $t_j$-values independently from an exponential distribution with a scale parameter of ten and rounded up to the nearest integer. To achieve partial negative correlation between $t_j$ and $f_j$, we then set $f_j = 1 / (t_j + 10\,Q)$, where $Q$ is drawn uniformly from the interval $[0, 1)$. In the first experiment, which concerns Alma's problem, we set each $g_j = 1$ and $H = h = \lfloor m/ 2 \rfloor$. In the second experiment, which concerns Ellis's problem, each $g_j$ is drawn uniformly from the set $\{5, \dots, 10\}$ and we set $H = \lfloor \frac{1}{2} \sum g_j \rfloor$. This cost distribution resembles real-world college application fees, which are often multiples of \$10 between \$50 and \$100. A typical instance is shown in Figure \ref{samplemarket}.
\else
실험 방법은 다음과 같다. 먼저, 가산 시장을 생성하기 위해 $t_j$-값을 평균이 10인 지수 분포에서 동립적으로 관측하고 정수로 올림했다. 그다음에, $t_j$와 $f_j$가 서로 부분적으로 반비례하게 만들도록 $f_j = 1 / (t_j + 10\,Q)$로 정의했다. 단, $Q$는 $[0, 1)$에서 균일한 확률로 관측한다. 알마의 문제를 고려하는 첫번째 실험에서, 모든 $g_j = 1$ 그리고 $H = h = \lfloor m/ 2 \rfloor$으로 처리했다. 엘리스의 문제를 고려하는 두번째 실험에서, 모든  $g_j$를 $\{5, \dots, 10\}$에서 균일한 확률로 관측했으며 $H = \lfloor \frac{1}{2} \sum g_j \rfloor$으로 처리했다. 실제 대학 지원 비용인 50~100달러 사이에 10달러의 어떤 배수이므로 합리적인 비용 분포이다. 그림 \ref{samplemarket}에서 전형적인 인스턴스가 나타난다.
\fi

\ifen
The experimental variables were the market size $m$, the choice of algorithm, and (for Algorithm \ref{ellisDP3}) the tolerance $\varepsilon$. For each combination of the experimental variables, we generated \nmarkets~markets, and the optimal portfolio was computed three times, with the fastest of the three repetitions recorded as the computation time. We then report the mean and standard deviation across the \nmarkets~markets. Therefore, each cell of each table below represents a statistic over {\the\numexpr 3 * \nmarkets \relax}~computations. Where applicable, we do not count the time required to sort the entries of $t$.
\else
실험 변수로는 시장의 크기 $m$, 해법 선택, 그리고 (알고리즘 \ref{ellisDP3}인 경우) 허용치 $\varepsilon$을 고려했다. 실험 변수의 각 조합에 대해,  \nmarkets 개의 시장을 생성했으며 최적 포트폴리오를 3번 계산 한 것 중 가장 빠른 것으로 계산 시간으로 기록했다. \nmarkets 개의 시장에 대한 평균과 평균편차를 표에 나타낸다. 따라서 아래 표의 각 칸은 {\the\numexpr 3 * \nmarkets \relax}개의 계한에 대한 통계다. $t$를 배열하는 시간은 고려하지 않았다.
\fi


\ifen \subsection{Summary of results} \else \subsection{결과 정리}\fi
\ifen
In our first experiment, we compare the performance of Algorithm \ref{algorithmforlargeh} for homogeneous-cost markets of various sizes when the set of candidate schools $\mathcal{C}$ is stored as a list and as a binary max heap ordered by the $f_j \bar t_j$-values. The results appear in Table \ref{experiment1results}. Our results indicate that the list implementation is faster. %However, the ratio between the average times of the two implementations stays roughly constant, suggesting that a more effective heap implementation could be competitive in certain classes of problem instances. Overall, the rate of growth is quadratic in $m$, which accords with the $O(hm)$ time complexity result of Theorem \ref{validityofalmaalgorithm}.
\else
첫번째 실험에서, 동일한 지원 비용으로 정의된 크기가 다양한 시장에 대해 알고리즘 \ref{algorithmforlargeh}의 성능을 고려했다. 이를 $\mathcal{C}$를 목록 혹은 $f_j \bar t_j$-값에 따라 배열된 힙 구현으로 구성하는 경우로 나눴으며 실험 결과는 표 \ref{experiment1results}에서 등장한다. 실험 결과에 따라 목록 구현이 더 빠른 해법이었다. %그러나, 두개의 방법 사이에 계산 시간 비율은 거의 상수이므로 개선된 힙 해법이 어떤 문제 인스턴스에 대해 더 빠를 가능성이 있어 보인다. 전체적으로 계산 시간은 $m$의 제곱으로 늘아나며 이는 정리 \ref{validityofalmaalgorithm}에서 말한 $O(hm)$-시간과 동의한다.
\fi

%\ifen
%In our first experiment, we compare the performance of Algorithm \ref{algorithmforlargeh} for homogeneous-cost markets of various sizes when the set of candidate schools $\mathcal{C}$ is stored as a list and as a binary max heap ordered by the $f_j \bar t_j$-values. The results appear in Table \ref{experiment1results}. Our results indicate that the heap implementation is faster. Overall, the rate of growth is quadratic in $m$, which accords with the $O(hm)$ time complexity result of Theorem \ref{validityofalmaalgorithm}.
%\else
%첫번째 실험에서, 동일한 지원 비용으로 정의된 크기가 다양한 시장에 대해 알고리즘 \ref{algorithmforlargeh}의 성능을 고려했다. 이를 $\mathcal{C}$를 목록 혹은 $f_j \bar t_j$-값에 따라 배열된 힙 구현으로 구성하는 경우로 나눴으며 실험 결과는 표 \ref{experiment1results}에서 등장한다. 실험 결과에 따라 힙 구현이 더 빠른 해법이었다. 전체적으로 계산 시간은 $m$의 제곱으로 늘아나며 이는 정리 \ref{validityofalmaalgorithm}에서 말한 $O(hm)$-시간과 동의한다.
%\fi

\ifen
In the second experiment, we turn to the general problem, and compare the performance of the exact algorithms (Algorithms \ref{ellisbnb} and \ref{ellisDP1}) and the approximation scheme (Algorithm \ref{ellisDP3}) at tolerances 0.5 and 0.05.  The results, which appear in Table \ref{experiment2results}, broadly agree with the time complexity analyses presented above. The branch-and-bound algorithm proved impractical for even medium-sized instances. Overall, we found the exact dynamic program to be the fastest algorithm, while the FPTAS was rather slow, a result that echoes the results of computational studies on knapsack problems (Martello and Toth 1990, \S\,2.10).

The strong performance of Algorithm \ref{ellisDP1} is partly attributable to the structure of our synthetic instances, in which application costs are small integers and $H$ is proportional in expectation to $m$, meaning the expected computation time is $O(m^2)$. However, the relative advantage of Algorithm \ref{ellisDP1} is even more pronounced in real college-application instances because the typical student's application budget accommodates at most a dozen or so schools and is constant in $m$. 
\else
두번째 실험에서 일반적 문제를 고려한다. 정확한 해법 (알고리즘 \ref{ellisbnb} 및 알고리즘 \ref{ellisDP1}) 그리고 허용치를 0.5와 0.05로 설정한 근사 해법 (알고리즘 \ref{ellisDP3})의 성능을 비교한다. 실험 결과는 표 \ref{experiment1results}에서 나타나며 위에서 도출한 시간 복잡성 결과와 대략 같다. 정확한 동적계획 해법이 전책적으로 가장 빠르며 FPTAS가 약간 느린 것으로 나온 결과는 배낭 문제 해법을 비교한 기존 연구와 비슷하다 (Martello와 Toth 1990, \S\,2.10). 분지한계법은 크기가 중간인 인스턴스에도 비효율적이었다. 

알고리즘 \ref{ellisDP1}의 좋은 실험적 성능은 부분적으로 가상 인스턴스의 구조 덕이다. 가상 인스턴스의 지원 비용이 작은 정수이고 $H$가 $m$과 선형식으로 비례하는 것은 알고리즘의 기대 계산 시간이 $O(m^2)$임을 의미한다. 그러나 전형적인 학생의 지원 예산은 최대한 열 몇 개의 학교에 지원할 수 있게 하며 $m$에 대해 상수이므로, 실제 대학 지원 문제 인스턴스에 적용하면 알고리즘 \ref{ellisDP1}이 더욱 뚜렷한 상대적 우위를 발휘한다. 
\fi




\newcommand{\lastptofcaption}{\ifen
For each value of $m$, \nmarkets~markets were generated, and the computation time was recorded as fastest of three repetitions of the algorithm. The table shows the average time (standard deviation) over the \nmarkets~instances.
\else 각 $m$에 대해 \nmarkets 개의 시장을 생성했으며 알고리즘을 3번 반복해서 그 중 최소 계산 시간을 기록했다. 표에서 \nmarkets 개의 인스턴스에 대한 평균 (평균편차) 시간이 나타난다.\fi}

\begin{table}[h!] \centering
\small
\begin{tabular}{r|r@{~}r|r@{~}r}
\ifen 
 \textbf{\begin{tabular}[r]{@{}r@{}}Number of\\schools $m$\end{tabular}}& \multicolumn{2}{c|}{\textbf{\begin{tabular}[c]{@{}c@{}}Algorithm \ref{algorithmforlargeh}\\with list\end{tabular}}}  & \multicolumn{2}{c}{\textbf{\begin{tabular}[c]{@{}c@{}}Algorithm \ref{algorithmforlargeh}\\with heap\end{tabular}}}\\ \hline
 \else
 \textbf{\begin{tabular}[r]{@{}r@{}}학교의\\개수 $m$\end{tabular}}& \multicolumn{2}{c|}{\textbf{\begin{tabular}[c]{@{}c@{}}알고리즘 \ref{algorithmforlargeh}\\(목록 구현)\end{tabular}}}  & \multicolumn{2}{c}{\textbf{\begin{tabular}[c]{@{}c@{}}알고리즘 \ref{algorithmforlargeh}\\(힙 구현)\end{tabular}}}\\ \hline
 \fi
    16 &           0.00 &        (0.00) &           0.01 &        (0.00) \\
    64 &           0.03 &        (0.00) &           0.08 &        (0.02) \\
   256 &           0.15 &        (0.01) &           0.97 &        (0.22) \\
  1024 &           2.31 &        (0.05) &          14.44 &        (1.66) \\
  4096 &          37.85 &        (0.61) &         245.74 &       (17.33) \\
 16384 &         585.75 &        (2.11) &        4728.59 &      (552.25)
\end{tabular}
\caption{\label{experiment1results} \normalsize
\ifen Time in ms to compute an optimal portfolio for an admissions market with homogeneous application costs using Algorithm \ref{algorithmforlargeh} when $\mathcal{C}$ is stored as a list and as a heap. \lastptofcaption~In every case, $h = m/2$. 
\else 알고리즘 \ref{algorithmforlargeh}에서 $\mathcal{C}$를 목록 또는 힙 구현으로 저장했을 때, 
동일 지원 비용 입학 시장의 최적 지원 포트폴리오를 계산하는 시간. 단위: ms. \lastptofcaption~모든 경우, $h = m/2$. \fi}
\end{table}






\begin{table}[h!] \centering
\small
\begin{tabular}{r|r@{~}r|r@{~}r|r@{~}r|r@{~}r}
\ifen
\textbf{\begin{tabular}[r]{@{}r@{}}Number of\\schools $m$\end{tabular}}&\multicolumn{2}{c|}{\textbf{\begin{tabular}[c]{@{}c@{}}Algorithm \ref{ellisbnb}:\\Branch \& bound\end{tabular}}}  & \multicolumn{2}{c|}{\textbf{\begin{tabular}[c]{@{}c@{}}Algorithm \ref{ellisDP1}:\\Costs DP\end{tabular}}}  &\multicolumn{2}{c|}{\textbf{\begin{tabular}[c]{@{}c@{}}Algorithm \ref{ellisDP3}:\\FPTAS, $\varepsilon= 0.5$\end{tabular}}}  & \multicolumn{2}{c}{\textbf{\begin{tabular}[c]{@{}c@{}}Algorithm \ref{ellisDP3}:\\FPTAS, $\varepsilon= 0.05$\end{tabular}}}   \\ \hline
\else
\textbf{\begin{tabular}[r]{@{}r@{}}학교의\\개수 $m$\end{tabular}}&\multicolumn{2}{c|}{\textbf{\begin{tabular}[c]{@{}c@{}}알고리즘  \ref{ellisbnb}:\\분지한계법\end{tabular}}}  & \multicolumn{2}{c|}{\textbf{\begin{tabular}[c]{@{}c@{}}알고리즘 \ref{ellisDP1}: 지원\\비용 동적 계획\end{tabular}}}  &\multicolumn{2}{c|}{\textbf{\begin{tabular}[c]{@{}c@{}}알고리즘 \ref{ellisDP3}:\\FPTAS, $\varepsilon= 0.5$\end{tabular}}}  & \multicolumn{2}{c}{\textbf{\begin{tabular}[c]{@{}c@{}}알고리즘 \ref{ellisDP3}:\\FPTAS, $\varepsilon= 0.05$\end{tabular}}}   \\ \hline
\fi
     8 &          0.04 &       (0.02) &         0.01 &      (0.00) &                0.05 &             (0.01) &                 0.21 &              (0.06) \\
    16 &          0.22 &       (0.11) &         0.07 &      (0.01) &                0.43 &             (0.10) &                 3.15 &              (0.74) \\
    32 &        166.20 &     (422.31) &         0.31 &      (0.05) &                2.38 &             (0.38) &                33.38 &             (11.68) \\
    64 &             — &          (—) &         1.36 &      (0.18) &               15.32 &             (2.77) &               405.73 &            (125.98) \\
   128 &             — &          (—) &         6.52 &      (0.72) &               84.50 &            (22.59) &              2362.19 &           (1095.11) \\
   256 &             — &          (—) &        31.23 &      (1.91) &             1085.60 &          (1186.24) &             22129.92 &           (6588.40)
\end{tabular}%
\caption{\label{experiment2results} \normalsize
\ifen Time in ms to compute an optimal or $(1 - \varepsilon)$-optimal portfolio for an admissions market with heterogeneous application costs using the three algorithms developed in Section \ref{hetappcosts}.
%branch-and-bound routine (Algorithm \ref{ellisbnb}), exact dynamic program (Algorithm \ref{ellisDP1}), and the fully polynomial-time approximation scheme (Algorithm \ref{ellisDP3}).
The branch-and-bound algorithm is impractical for large markets. \lastptofcaption
\else  %분지한계법 (알고리즘 \ref{ellisbnb}), 정확한 동적 계획 (알고리즘 \ref{ellisDP1}), 그리고 완전 다항 시간 근사 해법 (알고리즘 \ref{ellisDP3})을
 \ref{hetappcosts}절에서 도출한 3개의 알고리즘을 사용할 때, 다양한 지원 비용으로 갖춘 입학 시장의 최적 또는 $(1- \varepsilon)$-최적 포트폴리오를 계산하는 시간. 단위: ms. 분지한계법은 큰 시장에서 비실용적이다. \lastptofcaption \fi}
\end{table}








\begin{figure}[h!] 
\centering
\includegraphics[width=0.85\textwidth]{./plots/samplemarket.pdf}
  \caption{\label{samplemarket}
 \ifen A typical randomly-generated instance with $m=64$ schools and its optimal application portfolio. The application costs $g_j$ were drawn uniformly from $\{5, \dots, 10\}$. The optimal portfolio was computed using Algorithm \ref{ellisDP1}.
 \else $m=64$개의 학교로 구성된 전형적인 무작위로 생성한 인스턴스와 해당 최적 포트폴리오. 지원 비용 $g_j$는 $\{5, \dots, 10\}$에서 균일한 확률로 선정했으며 기호의 넓이와 비례된다. 최적 포트폴리오는 알고리즘 \ref{ellisDP1}(으)로 계산했다. \fi}
\end{figure}





%\pagebreak
\ifen \section{Conclusion and ideas for future research} \else \section{결론과 향후 연구}\fi\label{conclusion}
\ifen
This study has introduced a novel combinatorial optimization problem that we call the college application problem. It can be viewed as a kind of integer portfolio optimization problem or nonlinear knapsack problem. We showed that the special case in which colleges have identical application costs can be solved in polynomial time by a greedy algorithm because the optimal solutions are nested in the budget constraint. The general problem is NP-complete. We provided three solution algorithms. The strongest from a theoretical standpoint is an FPTAS that produces a $(1-\varepsilon)$-approximate solution in $O(m^3 / \varepsilon)$-time. On the other hand, for typical college-application instances, the dynamic program based on application expenditures is both easier to implement and substantially more time efficient.

Three extensions of this problem appear amenable to future study.
\else
본 연구는 새로운 조합최적화 문제를 제안했으며 이를 대학 지원 최적화 문제라고 부른다. 정수 포트폴리오 최적화 문제 또는 확률적인 배낭 문제로 볼 수 있다. 모든 대학의 지원 비용이 동일한 특수한 경우, 탐욕 알고리즘으로 다항 시간 안에 풀 수 있음을 보였으며 최적해가 예산 제약식에 대한 포함 사슬 관계를 가지기 때문이다. 일반적인 문제는 NP-complete다. 3가지 해법을 제시했으며 이론적으로 가장 효율적인 알고리즘은 $O(m^3 / \varepsilon)$-시간 안에  $(1-\varepsilon)$-근사해를 계산하는 FPTAS이다. 그 반면에 전형적인 대학 지원 문제 인스턴스에 대해서, 지원 비용 지출액 기반 동적 계획 해법은 실행하기 쉬울 뿐더러 계산 시간이 상당히 짧다.

이 문제를 확장할 수 있는 향후 연구 방향 3가지를 제안한다. 
\fi


\ifen \subsection{Explicit treatment of risk aversion}\else \subsection{위험 회피가 명시적인 모형}\fi
\ifen
The familiar Markowitz portfolio optimization model includes an explicit risk-aversion term, whereas our model has settled for an implicit treatment of risk, namely the tradeoff between selective schools and safety schools inherent in the maximax objective function. However, it is possible to augment the objective function $v(\mathcal{X}) = \operatorname{E}[X]$ to incorporate a variance penalty $\beta \geq 0$ as follows:
\else
익숙한 Markowitz 포트폴리오 최적화 모형에는 명시적인 위험 회피 항이 있으며, 본 모형은 maximax 목적함수에 내포된 경쟁적인 학교와 안정 학교 사이의 균형에 의한 위험 관리 요소만 고려했다. 그러나 기본 목적함수인 $v(\mathcal{X}) = \operatorname{E}[X]$에 평균편차 페널티 $\beta \geq 0$를 다음처럼 도입할 수 있다:
\fi
\begin{align}
\begin{split}
v_{\mathrm{\beta}}(\mathcal{X}) &=  \operatorname{E}[X] - \beta \operatorname{Var}(X) \\
&=   \operatorname{E}[X] - \beta \left(  \operatorname{E}[X^2]  -  \operatorname{E}[X]^2 \right) \\
& = \sum_{j\in\{0\}\cup\mathcal{X}} \Bigl( f_j t_j \prod_{\substack{i \in \mathcal{X}: \\ i > j}} (1 - f_{i}) \Bigr)
 - \beta \sum_{j\in\{0\}\cup\mathcal{X}} \Bigl( f_j t_j^2 \prod_{\substack{i \in \mathcal{X}: \\ i > j}} (1 - f_{i}) \Bigr)
  + \beta v(\mathcal{X})^2 \\
  &= v(\mathcal{X}; \tau) +  \beta v(\mathcal{X}; t)^2
\end{split}
\end{align}
\ifen
where $\tau_j = t_j - \beta t_j^2$. Since the first term is itself a portfolio valuation function, and the second is a monotonic transformation of one, we speculate that one of the algorithms given above could be used as a subroutine to trace out the efficient frontier by maximizing $v(\mathcal{X}; t)$ subject to the budget constraint and $v(\mathcal{X}; \tau) \geq \alpha$ for various values of $\alpha \geq 0$. 
\else
단, $\tau_j = t_j - \beta t_j^2$. 이의 첫번째 항 그 자체가 포트폴리오 가치 함수이며, 두번째 항은 포트폴리오 가치 함수의 단조 변환이다. 따라서 위에서 제시한 알고리즘을 서브루틴으로 사용하면 효율적 투자선(efficient frontier)을 탐색할 수 있어 보인다. 이때 다양한 $\alpha \geq 0$에 대해 예산 제약식과 $v(\mathcal{X}; \tau) \geq \alpha$ 하에서 $v(\mathcal{X}; t)$을 최대화하는 것이 알고리즘의 요점이다.
\fi


\ifen \subsection{Signaling strategies}\else \subsection{시그런 전략}\fi
\ifen
Another direction of further research with immediate application in college admissions is to incorporate additional signaling strategies into the problem. In the Korean admissions process, the online application form contains three multiple-choice fields, labeled \emph{ga, na,} and \emph{da} for the first three letters of the Korean alphabet, which students use to indicate the colleges to which they wish to apply. Most schools appear only in one or two of the three fields. Therefore, students are restricted not only in the number of applications they can submit, but in the combinations of schools that may coincide in a feasible application portfolio. From a portfolio optimization perspective, this is a \emph{diversification constraint,} because its primary purpose is to prevent students from applying only to top-tier schools. However, in addition to overall selectivity, the three fields also indicate different evaluation schemes: Applications filed under the \emph{ga} and {na} fields are evaluated with greater emphasis on standardized-test scores than those filed under the \emph{da} field. Some colleges appear in multiple fields and run two parallel admissions processes, each with different evaluation criteria. Therefore, if a student recognizes that she has a comparative advantage in (for example) her interview skills, she may increase her chances of admission to a competitive school by applying under the \emph{ga} field. Clearly, the optimal application strategy in this context can be quite subtle, and are a perennial subject of debate on Korean social networks.

An analogous feature of the American college admissions process is known as early decision, in which at the moment of application, a student commits to enrolling in a college if admitted. In principle, students who apply with early decision may obtain a better chance of admission by signaling their eagerness to attend, but doing so weakens the college's incentive to entice the student with merit-based financial aid, altering the utility calculus.
\else
향후 연구에 두번째 방향은 모형에 시그널 전략을 도입하는 것이다. 한국 입학 과정의 온라인 지원 양식에는 가군, 나군, 다군이란 3가지 선다형 칸을 채워서 지원하는 학교를 선택한다. 대부분의 학교는 모든 3개의 칸에 등장하지 않고 그 중 1~2개만 가능하다. 따라서 학생이 지원할 수 있는 학교의 `수'일 뿐만 아니라 가능한 지원 포트폴리오에 같이 들어갈 수 있는 학교의 `조합'도 제한된다. 이는 학생이 상위권 대학만 지원하지 않도록 만들어지기 때문에  다각화(diversification) 제약식으로 볼 수 있다. 그러나 대학이 어떤 군에 속하는 것은 대학 순위일 뿐더러 입학 전형 유형도 의미한다. 가군과 나군으로 지원하는 경우, 다군보다 수능 점수의 반영 비율이 높다. 또한 군 2개에 포함되는 학교도 있으며 입학 전형이 다르면서 평행한 모집 과정 2개를 운영한다. 가령, 어떤 학생이 면접 능력에 비교 우위가 있으면 경쟁적인 학교에 가군으로 지원하면 합격 확률을 높일 수 있다. 이런 맥락에서 최적의 지원 전략은 미묘한 문제이며 한국 SNS에서 자주 발생하는 화젯거리다.

미국 입학 과정의 유사한 특징은 조기 전형(early decision)이다. 이는 학생이 합격하면 진학한다고 약속하고 지원하는 것을 의미한다. 조기 전형으로 지원하면 입학할 관심을 시그널할 수 있으므로 합격 확률을 높일 수 있는 반면에, 학교가 학생을 모집하려고 장학금을 수여할 동기가 약화할 수 있으므로 학생의 효용 추정이 달라진다.
\fi


\ifen
In the integer formulation of the college application problem (Problem \ref{integernlp}), a natural way to model these signaling strategies without introducing too much complexity is to split each $c_j$ into $c_{j+}$ and $c_{j-}$. The binary decision variables are $x_{j+} = 1$ if the student applies to $c_j$ with high priority (that is, in  the \emph{ga} or \emph{na} field or with early decision) and $x_{j-} = 1$ if applying with low priority (that is, in the \emph{da} field or without early decision). Now, assuming that the differential admission probabilities $f_{j+}$ and $f_{j-}$ and utilities $t_{j+}$ and $t_{j-}$ are known, adding the logical constraints 
\begin{align}
 x_{j+} + x_{j-} \leq 1, ~~ j = 1\dots m\qquad\text{and}\qquad\sum_{j=1}^m x_{j+} \leq 1
\end{align}
completes the formulation. These constraints are conformable to those of the multiple knapsack problem (Kellerer et al. 2004, chap. 10). 
\else
대학 지원 문제의 정수 모형(문제 \ref{integernlp})에서 위의 시그널 전략들을 어렵지 않게 도입하는 방식은 각 $c_j$를 $c_{j+}$와 $c_{j-}$로 나누는 것이다. 그다음에 학생이 $c_j$에 높은 관심을 시그널하면 (즉, 가군으로 선택하거나 조기 전형으로 지원하면) $x_{j+} = 1$이며 관심을 시그널 하지 않고 지원하면 (즉 가군 혹은 나군으로 지원하거나 조기 전형 없이 지원하면) $x_{j-} = 1$이 되는 이진 결정 변수를 정의한다. 그러면 해당 합격 확률 $f_{j+}$와 $f_{j-}$ 그리고 효용  $t_{j+}$와 $t_{j-}$가 알려져 있다고 가정하면 다음 같은 논리 제약식을 더해서 모형을 완성할 수 있다. 
\begin{align}
 x_{j+} + x_{j-} \leq 1, ~~ j = 1\dots m\qquad\text{그리고}\qquad\sum_{j=1}^m x_{j+} \leq 1
\end{align}
다중 배낭 문제의 제약식과 같을 꼴이다 (Kellerer et al. 2004, 10제). 
\fi


\ifen \subsection{Memory-efficient dynamic programs}\else \subsection{동적 계획의 메모리 소요 절감}\fi
\ifen
Our numerical experiments suggest that the performance of the dynamic programming algorithms is bottlenecked by not computation time, but memory usage. Reducing these algorithms' storage requirements would enable us to solve considerably larger problems.

Abstractly speaking, Algorithms \ref{ellisDP1} and \ref{ellisDP3} are two-dimensional dynamic programs that represent the optimal solution by $Z[N, C]$. Here $N$ is the number of decision variables, $C$ is a constraint parameter, and $Z[n, c]$ is the optimal objective value achievable using the first $n\leq N$ decision variables when the constraint parameter is $c \leq C$. The algorithm iterates on a recursion relation that expresses $Z[n, c]$ as a function of $Z[n -1, c]$ and $Z[n -1, c']$ for some $c' \leq c$. (In Algorithm \ref{ellisDP1}, $Z$ is the maximal portfolio valuation, $N = m$, and $C =H$; in Algorithm \ref{ellisDP3},  $Z$ is the minimal application expenditures, $N = m$, and $C = |\mathcal{V}| \propto m^2 / \varepsilon$.)

When such a dynamic program is implemented using a lookup table or dictionary memoization, producing the optimal solution requires $O(NC)$-time and -space. Kellerer et al. (2004, \S\,3.3) provide a technique for transforming the dynamic program $Z$ into a divide-and-conquer algorithm that produces the optimal solution in $O(N C)$-time and $O(N + C)$-space, a significant improvement. However, their technique requires the objective function to be additively separable in a certain sense that appears difficult to conform to the college application problem. 
\else
수리 실험 결과에 따르면 동적 계획 해법 성능의 목병 요소는 계산 시간이 아니라 메모리 소모량이다. 이 알고리즘의 메모리 소요를 절감하면 상당히 큰 문제를 풀 수 있다.

추상적인 관점에서, 알고리즘 \ref{ellisDP1}과(와) 알고리즘 \ref{ellisDP3}은(는) 최적해를 $Z[N, C]$로 표현하는 2차원 동적 계획이다. 이때 $N$은 결정 변수의 수, $C$는 제약식의 모수, 그리고 $Z[n, c]$는 제약 모수가 $c \leq C$일 때 첫 $n\leq N$개의 결정 변수만 이용하는 최적해이다. 알고리즘의 구조는 $Z[n, c]$를 $Z[n -1, c]$와 어떤 $c' \leq c$에 대응하는 $Z[n -1, c']$의 함수로 표현하는 반복 관계로 탐색하는 것이다. (알고리즘 \ref{ellisDP1}에서 $Z$는 최대 포트폴리오 가치, $N = m$, 그리고 $C =H$이며, 알고리즘 \ref{ellisDP3}에서 $Z$는 최소한 지원 지출액, $N = m$, 그리고 $C= |\mathcal{V}| \propto m^2 / \varepsilon$이다.)

이러한 형태의 동적 계획을 표 혹은 사전 기록으로 구현하면 최적해를 출력하는 것은 $O(NC)$-시간과 -공간을 소요한다. Kellerer외 (2004, \S\,3.3)는 동적 계획 $Z$를 $O(N C)$-시간과 $O(N + C)$-공간으로 최적해를 구하는 분할 정복(divide and conquer) 알고리즘으로 변환하는 일잔적인 방법을 제시하며 매우 유익한 기술이다. 그러나 이를 이용할 수 있는 조건 중, 목적함수는 어떤 기술적인 의미에서 가산적으로 분할되어야 하며 이를 대학 지원 문제에 적용하기 어렵다.
\fi




\pagebreak
\ifen \section{References} \else \section{참고문헌} \fi
\noindent

\parskip 0em
\leftskip 2em
\parindent -2em
\ifen \else
김민희. 2015. ``{[대입 수시 전략]} 총 6번의 기회 $\cdots$ `상향·소신·안정' 분산 지원하라.'' 중앙일보, 8월 26일. \url{https://www.joongang.co.kr/article/18524069}.\fi

Acharya, Mohan S., Asfia Armaan, and Aneeta S. Antony. 2019. ``A Comparison of Regression Models for Prediction of Graduate Admissions.'' In \emph{Second International Conference on Computational Intelligence in Data Science.} \url{https://doi.org/10.1109/ICCIDS.2019.8862140}.

Balas, Egon and Eitan Zemel. 1980. ``An Algorithm for Large Zero-One Knapsack Problems.'' \emph{Operations Research} 28 (5): 1130--54. \url{https://doi.org/10.1287/opre.28.5.1130}. 

Bezanson, Jeff, Alan Edelman, Stefan Karpinski, and Viral B. Shah. 2017. ``Julia: A Fresh Approach to Numerical Computing.'' \emph{SIAM Review} 59: 65–98. \url{https://doi.org/10.1137/141000671}.

Budish, Eric. 2011. ``The Combinatorial Assignment Problem: Approximate Competitive Equilibrium from Equal Incomes.'' \emph{Journal of Political Economy} 119 (6): 1061--1103. \url{https://doi.org/10.1086/664613}. 

Carraway, Robert, Robert Schmidt, and Lawrence Weatherford. 1993. ``An algorithm for maximizing target achievement in the stochastic knapsack problem with normal returns.'' \emph{Naval Research Logistics} 40 (2): 161--73. \url{https://doi.org/10.1002/nav.3220400203}.

Dantzig, George B. 1957. ``Discrete-Variable Extremum Problems.'' \emph{Operations Research} 5 (2): 266--88.

Dean, Brian, Michel Goemans, and Jan Vondr\'ak. 2008. ``Approximating the Stochastic Knapsack Problem: The Benefit of Adaptivity.'' \emph{Mathematics of Operations Research} 33 (4): 945--64. \url{https://doi.org/10.1287/moor.1080.0330}.

Kellerer, Hans, Ulrich Pferschy, and David Pisinger. 2004. \emph{Knapsack Problems.} Berlin: Springer.

\ifen Kim, Minhee. 2015. ``[College application strategy] Six chances total\dots divide applications across reach, target, and safety schools'' (in Korean). Jungang Ilbo, Aug. 26. \url{https://doi.org/10.1086/664613}\fi

Fisher, Marshall, George Nemhauser, and Laurence Wolsey. 1978. ``An analysis of approximations for maximizing submodular set functions—I.'' \emph{Mathematical Programming} 14: 265--94. 

Fredman, Michael Lawrence and Robert Tarjan. 1987. ``Fibonacci heaps and their uses in improved network optimization algorithms.'' \emph{Journal of the Association for Computing Machinery} 34 (3): 596--615.

Fu, Chao. 2014. ``Equilibrium Tuition, Applications, Admissions, and Enrollment in the College Market.'' \emph{Journal of Political Economy} 122 (2): 225--81. \url{https://doi.org/10.1086/675503}. 

Garey, Michael and David Johnson. 1979. \emph{Computers and Intractability: A Guide to the Theory of NP-Completeness.} New York: W. H. Freeman and Company. 

Markowitz, Harry. 1952. ``Portfolio Selection.'' \emph{The Journal of Finance} 7 (1): 77--91. \url{https://www.jstor.org/stable/2975974}.

Martello, Silvano and Paolo Toth. 1990. \emph{Knapsack Problems: Algorithms and Computer Implementations.} New York: John Wiley \& Sons. 

Meucci, Attilio. 2005. \emph{Risk and Asset Allocation.} Berlin: Springer-Verlag, 2005. 

Othman, Abraham, Eric Budish, and Tuomas Sandholm. 2010. ``Finding Approximate Competitive Equilibria: Efficient and Fair
Course Allocation.'' In \emph{Proceedings of 9th International Conference on Autonomous Agents and Multiagent Systems.} New York: ACM. \url{https://dl.acm.org/doi/abs/10.5555/1838206.1838323}.

Rozanov, Mark and Arie Tamir. 2020. ``The nestedness property of the convex ordered median location problem on a tree.'' \emph{Discrete Optimization} 36: 100581. \url{https://doi.org/10.1016/j.disopt.2020.100581}.

Sklarow, Mark. 2018. \emph{State of the Profession 2018: The 10 Trends Reshaping Independent Educational Consulting.} Technical report, Independent Eduational Consultants Association. \url{https://www.iecaonline.com/wp-content/uploads/2020/02/IECA-Current-Trends-2018.pdf}.

Sniedovich, Moshe. 1980. ``Preference Order Stochastic Knapsack Problems: Methodological Issues.'' \emph{The Journal of the Operational Research Society} 31 (11): 1025--32. \url{https://www.jstor.org/stable/2581283}. 

Steinberg, E. and M. S. Parks. 1979. ``A Preference Order Dynamic Program for a Knapsack Problem with Stochastic Rewards.'' \emph{The Journal of the Operational Research Society} 30 (2): 141--47. \url{https://www.jstor.org/stable/3009295}. 

% Another ex of nestedness.
%Tibshirani, Robert. 1996. ``Regression Shrinkage and Selection via the Lasso.'' \emph{Journal of the Royal Statistical Society,. Series B (Methodological)} 58, no. 1: 267--88. \url{https://www.jstor.org/stable/2346178}.

Vazirani, Vijay. 2001. \emph{Approximation Algorithms.} Berlin: Springer. 

\end{document}  

